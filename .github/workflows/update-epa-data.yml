name: Update EPA data

on:
  schedule:
    - cron: '0 12 * * 2'
  workflow_dispatch:
    inputs:
      mode:
        description: "update_current, backfill_season, backfill_range"
        required: true
        default: update_current
        type: choice
        options:
          - update_current
          - backfill_season
          - backfill_range
      season:
        description: "Season year (used when mode=backfill_season)"
        required: false
      season_start:
        description: "Start season year (used when mode=backfill_range)"
        required: false
        default: "2000"
      season_end:
        description: "End season year (optional; defaults to current season when mode=backfill_range)"
        required: false
  push:
    branches: [ main ]
    paths:
      - .github/workflows/update-epa-data.yml

concurrency:
  group: epa-data
  cancel-in-progress: false

permissions:
  contents: write

env:
  # Always start backfilling from the year 2000
  SEASON_START: "2000"
  AUTO_BACKFILL_BATCH: "5"

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Sync to latest branch HEAD
        run: |
          set -euo pipefail
          branch="${GITHUB_REF_NAME}"
          git fetch origin "$branch"
          git checkout -B "$branch" "origin/$branch"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt

      - name: Determine next season to backfill (scheduled)
        if: ${{ github.event_name == 'schedule' }}
        id: auto
        run: |
          set -euo pipefail
          python - <<'PY'
import os
import sqlite3
from datetime import datetime
from pathlib import Path

db_path = Path("data/epa.sqlite")
db_path.parent.mkdir(parents=True, exist_ok=True)

now = datetime.utcnow()
current_season = now.year if now.month >= 9 else now.year - 1
start_season = int(os.environ.get("SEASON_START", "2000"))
batch_size = max(int(os.environ.get("AUTO_BACKFILL_BATCH", "5")), 1)

seasons_in_db = set()
if db_path.exists():
    conn = sqlite3.connect(str(db_path))
    try:
        try:
            rows = conn.execute("SELECT DISTINCT season FROM team_epa_weekly").fetchall()
        except sqlite3.OperationalError as exc:
            # If table doesn't exist yet, treat as empty.
            if "no such table" in str(exc):
                rows = []
            else:
                raise
        seasons_in_db = {int(r[0]) for r in rows if r and r[0] is not None}
    finally:
        conn.close()

missing = [s for s in range(start_season, current_season + 1) if s not in seasons_in_db]
seasons_to_fetch = sorted(missing, reverse=True)[:batch_size]

out = Path(os.environ["GITHUB_OUTPUT"])
with out.open("a", encoding="utf-8") as f:
    if not seasons_to_fetch:
        f.write("did_find_season=false\n")
    else:
        f.write("did_find_season=true\n")
        f.write("seasons_to_fetch=" + ",".join(str(s) for s in seasons_to_fetch) + "\n")

print("seasons_in_db_count=", len(seasons_in_db))
print("seasons_to_fetch=", ",".join(str(s) for s in seasons_to_fetch))
PY

      - name: Determine season target
        id: season
        run: |
          set -euo pipefail
          SEASON_START="${{ env.SEASON_START }}"

          current_year="$(date -u '+%Y')"
          current_month="$(date -u '+%m')"
          if [ "$current_month" -ge 9 ]; then
            current_season="$current_year"
          else
            current_season=$((current_year - 1))
          fi

          mode="${{ github.event.inputs.mode || 'update_current' }}"
          season_input="${{ github.event.inputs.season || '' }}"
          season_start_input="${{ github.event.inputs.season_start || '' }}"
          season_end_input="${{ github.event.inputs.season_end || '' }}"

          case "$mode" in
            update_current)
              season="$current_season"
              season_start="$season"
              season_end="$season"
              ;;
            backfill_season)
              if [ -n "$season_input" ]; then
                season="$season_input"
              else
                season="$current_season"
              fi
              season_start="$season"
              season_end="$season"
              ;;
            backfill_range)
              if [ -n "$season_start_input" ]; then
                season_start="$season_start_input"
              else
                season_start="$SEASON_START"
              fi
              if [ -n "$season_end_input" ]; then
                season_end="$season_end_input"
              else
                season_end="$current_season"
              fi
              season="$season_end"
              ;;
            *)
              echo "Unknown mode: $mode" >&2
              exit 1
              ;;
          esac

          echo "mode=$mode" >> "$GITHUB_OUTPUT"
          echo "season=$season" >> "$GITHUB_OUTPUT"
          echo "season_start=$season_start" >> "$GITHUB_OUTPUT"
          echo "season_end=$season_end" >> "$GITHUB_OUTPUT"

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Refresh SQLite cache
        if: ${{ steps.season.outputs.mode != 'backfill_range' }}
        run: |
          set -euo pipefail
          season=${{ steps.season.outputs.season }}
          echo "Fetching season $season"
          python -m scripts.fetch_epa --season "$season" --db data/epa.sqlite --include-playoffs
          python -c "import sqlite3; c=sqlite3.connect('data/epa.sqlite'); c.execute('PRAGMA wal_checkpoint(TRUNCATE);'); c.close()"
          rm -f data/epa.sqlite-wal data/epa.sqlite-shm

      - name: Refresh SQLite cache (range)
        if: ${{ steps.season.outputs.mode == 'backfill_range' }}
        run: |
          set -euo pipefail
          start=${{ steps.season.outputs.season_start }}
          end=${{ steps.season.outputs.season_end }}
          for season in $(seq $start $end); do
            echo "Backfilling season $season"
            python -m scripts.fetch_epa --season "$season" --db data/epa.sqlite --include-playoffs
            python -c "import sqlite3; c=sqlite3.connect('data/epa.sqlite'); c.execute('PRAGMA wal_checkpoint(TRUNCATE);'); c.close()"
            rm -f data/epa.sqlite-wal data/epa.sqlite-shm
          done

      - name: Fetch next missing seasons (scheduled)
        if: ${{ github.event_name == 'schedule' && steps.auto.outputs.did_find_season == 'true' }}
        run: |
          set -euo pipefail
          IFS=',' read -ra seasons <<< "${{ steps.auto.outputs.seasons_to_fetch }}"
          for season in "${seasons[@]}"; do
            echo "Auto-backfilling missing season: $season"
            python -m scripts.fetch_epa --season "$season" --db data/epa.sqlite --include-playoffs
            python -c "import sqlite3; c=sqlite3.connect('data/epa.sqlite'); c.execute('PRAGMA wal_checkpoint(TRUNCATE);'); c.close()"
            rm -f data/epa.sqlite-wal data/epa.sqlite-shm
          done

      - name: Export static JSON
        run: |
          python -m scripts.export_epa_json --db data/epa.sqlite --output data/epa.json

      - name: Validate exported payload
        env:
          MODE: ${{ steps.season.outputs.mode }}
          TARGET_SEASON: ${{ steps.season.outputs.season }}
          RANGE_START: ${{ steps.season.outputs.season_start }}
          RANGE_END: ${{ steps.season.outputs.season_end }}
          SEASONS_TO_FETCH: ${{ steps.auto.outputs.seasons_to_fetch }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          python - <<'PY'
import json
import os
from pathlib import Path

payload = json.loads(Path("data/epa.json").read_text())
seasons = payload.get("seasons", {})
if not seasons:
    raise SystemExit("No seasons found in export")

mode = os.environ.get("MODE", "")
target = os.environ.get("TARGET_SEASON", "")
start = os.environ.get("RANGE_START", "")
end = os.environ.get("RANGE_END", "")
event = os.environ.get("EVENT_NAME", "")
seasons_to_fetch = [s.strip() for s in os.environ.get("SEASONS_TO_FETCH", "").split(",") if s.strip()]

# Validate what *this run* claims to have generated
if mode == "backfill_range":
    if not start or not end:
        raise SystemExit("backfill_range requires RANGE_START and RANGE_END")
    s = int(start); e = int(end)
    missing = [str(y) for y in range(s, e + 1) if str(y) not in seasons]
    if missing:
        raise SystemExit(f"Missing seasons in export: {', '.join(missing)}")
else:
    if target and str(target) not in seasons:
        raise SystemExit(f"Target season {target} missing from export")

# If scheduled run also backfilled seasons, validate those too
if event == "schedule" and seasons_to_fetch:
    missing_scheduled = [s for s in seasons_to_fetch if s not in seasons]
    if missing_scheduled:
        raise SystemExit("Scheduled backfill expected seasons in export: " + ", ".join(missing_scheduled))

print("Export validation passed")
PY

      - name: Final checkpoint before commit
        run: |
          set -euo pipefail
          python -c "import sqlite3; conn=sqlite3.connect('data/epa.sqlite'); conn.execute('PRAGMA wal_checkpoint(TRUNCATE);'); conn.close()"
          rm -f data/epa.sqlite-wal data/epa.sqlite-shm

      - name: Commit and push updates
        run: |
          git add data/epa.sqlite data/epa.json
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          season_start="${{ steps.season.outputs.season_start }}"
          season_end="${{ steps.season.outputs.season_end }}"
          git commit -m "chore: refresh all seasons ${season_start}-${season_end}"
          branch="${GITHUB_REF_NAME}"
          git push origin HEAD:"$branch"
