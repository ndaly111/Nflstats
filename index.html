<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NFL EPA Explorer (Static)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
  <style>
    :root {
      color-scheme: light;
      --border: #e2e8f0;
      --text: #0f172a;
      --muted: #475569;
      --panel: #f8fafc;
    }

    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      color: var(--text);
      margin: 0;
      padding: 2rem 1.5rem 3rem;
      background: #ffffff;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      margin-bottom: 0.5rem;
    }

    h1 {
      margin: 0 0 0.35rem;
      font-size: 1.9rem;
    }

    p.lead {
      margin: 0 0 0.65rem;
      color: var(--muted);
    }

    .meta {
      color: var(--muted);
      font-size: 0.95rem;
      margin: 0 0 1rem;
    }

    .controls {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0 1.5rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.25rem;
    }

    select, button {
      width: 100%;
      padding: 0.6rem 0.7rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
      background: white;
    }

    button {
      cursor: pointer;
      font-weight: 700;
      color: white;
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      border: none;
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.2);
    }

    .hof-link {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.5rem 0.9rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: white;
      font-weight: 700;
      color: #0f172a;
      text-decoration: none;
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.08);
      transition: transform 120ms ease, box-shadow 120ms ease;
      white-space: nowrap;
    }

    .hof-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(15, 23, 42, 0.12);
    }

    .chart-wrap {
      position: relative;
      width: 100%;
      /* ‚ÄúReasonable size‚Äù across laptop + mobile */
      height: clamp(360px, 65vh, 720px);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.75rem;
      background: #fff;
      overflow: hidden;
    }

    .chart-wrap canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }

    @media (max-width: 640px) {
      .chart-wrap {
        height: clamp(320px, 60vh, 520px);
        padding: 0.5rem;
      }
    }

    .notice {
      background: #fff7ed;
      border: 1px solid #fed7aa;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
      color: #9a3412;
    }

    footer {
      margin-top: 1.5rem;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .table-wrapper {
      margin-top: 1.5rem;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      background: var(--panel);
    }

    .table-wrapper h2 {
      margin: 0 0 0.35rem;
    }

    .table-note {
      margin: 0 0 0.75rem;
      color: var(--muted);
    }

    .table-scroll {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
      background: white;
      border-radius: 10px;
      overflow: hidden;
    }

    th, td {
      padding: 0.55rem 0.65rem;
      border: 1px solid var(--border);
      text-align: left;
      white-space: nowrap;
    }

    th {
      background: #f8fafc;
      cursor: pointer;
      user-select: none;
    }

    th.sorted-asc::after { content: " \2191"; }
    th.sorted-desc::after { content: " \2193"; }

    body:not(.sos-mode) .sos-only {
      display: none;
    }

    tbody tr:nth-child(odd) { background: #f8fafc; }
    tbody tr:nth-child(even) { background: #ffffff; }

    .metric-cell .metric-value { font-variant-numeric: tabular-nums; }
    .metric-cell .rank-label {
      font-weight: 700;
      font-size: 0.9rem;
      margin-left: 0.35rem;
    }

    .raw-value {
      color: #9ca3af;
      font-size: 0.85em;
      margin-left: 0.35rem;
    }

  </style>
</head>
<body>
  <main>
    <div class="top-bar">
      <div>
        <h1>NFL Offense vs Defense Efficiency</h1>
        <p class="lead">Explore team EPA/play without running a server. Pick your season and week range to redraw the chart in-place.</p>
      </div>
      <a class="hof-link" href="hof.html" aria-label="View EPA Hall of Fame">üèÜ HOF</a>
    </div>
    <div id="data-meta" class="meta"></div>
    <div id="status" class="notice" hidden></div>
    <section class="controls">
      <div>
        <label for="season-select">Season</label>
        <select id="season-select"></select>
      </div>
      <div>
        <label for="week-start">Start week</label>
        <select id="week-start"></select>
      </div>
      <div>
        <label for="week-end">End week</label>
        <select id="week-end"></select>
      </div>
      <div>
        <label for="metric-mode">EPA view</label>
        <select id="metric-mode">
          <option value="raw">Raw EPA/play</option>
          <option value="sos">SOS-adjusted EPA/play</option>
        </select>
      </div>
      <div id="sos-basis-wrap">
        <label for="sos-basis">Opponent strength basis</label>
        <select id="sos-basis">
          <option value="season_to_date" selected>Season-to-date (through end week)</option>
          <option value="window_only">Selected weeks only</option>
          <option value="full_season">Full season (hindsight)</option>
        </select>
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="update-btn">Update chart</button>
      </div>
    </section>

      <div class="chart-wrap">
        <canvas id="epa-chart" aria-label="EPA scatter chart" role="img"></canvas>
      </div>

      <section id="table-section" class="table-wrapper">
        <h2>EPA/play table</h2>
        <p class="table-note">Click any column header to sort. Combined EPA follows the selected view; SOS columns show play-weighted opponent ratings faced for each side of the ball (SOS rank #1 = hardest schedule).</p>
        <div class="table-scroll">
          <table id="epa-table">
            <thead>
              <tr>
                <th data-type="number">Rank</th>
                <th data-type="string">Team</th>
                <th data-type="number">Record</th>
                <th data-type="number">Win%</th>
                <th data-type="number">Combined EPA/play</th>
                <th class="sos-only" data-type="number">SOS faced (opp DEF)</th>
                <th class="sos-only" data-type="number">SOS faced (opp OFF)</th>
                <th data-type="number">Offense EPA/play</th>
                <th data-type="number">Defense EPA/play</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

    <footer>
      <p><strong>Tip:</strong> values shown come from a bundled dataset (data/epa.json). Replace that file with your own weekly EPA snapshots to publish updated charts on GitHub Pages.</p>
    </footer>
  </main>

  <script>
    const TEAM_COLORS = {
      ARI: '#97233F', ATL: '#A71930', BAL: '#241773', BUF: '#00338D', CAR: '#0085CA', CHI: '#0B162A',
      CIN: '#FB4F14', CLE: '#311D00', DAL: '#003594', DEN: '#FB4F14', DET: '#0076B6', GB: '#203731',
      HOU: '#03202F', IND: '#002C5F', JAX: '#101820', KC: '#E31837', LAC: '#0080C6', LAR: '#003594',
      LV: '#000000', MIA: '#008E97', MIN: '#4F2683', NE: '#002244', NO: '#D3BC8D', NYG: '#0B2265',
      NYJ: '#125740', PHI: '#004C54', PIT: '#101820', SEA: '#002244', SF: '#AA0000', TB: '#D50A0A',
      TEN: '#4B92DB', WAS: '#5A1414'
    };

    const TEAM_DISPLAY_NAMES = {
      ARI: 'Arizona', ATL: 'Atlanta', BAL: 'Baltimore', BUF: 'Buffalo', CAR: 'Carolina', CHI: 'Chicago',
      CIN: 'Cincinnati', CLE: 'Cleveland', DAL: 'Dallas', DEN: 'Denver', DET: 'Detroit', GB: 'Green Bay',
      HOU: 'Houston', IND: 'Indianapolis', JAX: 'Jacksonville', KC: 'Kansas City', LAC: 'LA Chargers',
      LAR: 'Los Angeles Rams', LV: 'Las Vegas', MIA: 'Miami', MIN: 'Minnesota', NE: 'New England',
      NO: 'New Orleans', NYG: 'NY Giants', NYJ: 'NY Jets', PHI: 'Philadelphia', PIT: 'Pittsburgh',
      SEA: 'Seattle', SF: 'San Francisco', TB: 'Tampa Bay', TEN: 'Tennessee', WAS: 'Washington'
    };

    const QUADRANT_BACKGROUND_COLORS = {
      'positive-positive': 'rgba(34, 197, 94, 0.12)',
      'positive-negative': 'rgba(56, 189, 248, 0.12)',
      'negative-positive': 'rgba(168, 85, 247, 0.12)',
      'negative-negative': 'rgba(239, 68, 68, 0.12)'
    };

    const statusEl = document.getElementById('status');
    const metaEl = document.getElementById('data-meta');
    const seasonSelect = document.getElementById('season-select');
    const weekStartSelect = document.getElementById('week-start');
    const weekEndSelect = document.getElementById('week-end');
    const metricModeSelect = document.getElementById('metric-mode');
    const sosBasisSelect = document.getElementById('sos-basis');
    const updateButton = document.getElementById('update-btn');
    const ctx = document.getElementById('epa-chart').getContext('2d');
    const tableSection = document.getElementById('table-section');
    const table = document.getElementById('epa-table');
    const tableBody = table.querySelector('tbody');
    const tableHeaders = table.querySelectorAll('th');
    const DATA_URL = new URL('data/epa.json', document.baseURI);
    DATA_URL.searchParams.set('v', Date.now().toString());

    let chart;
    let seasonData = {};
    const sortState = { column: null, direction: 'asc' };

    const quadrantPlugin = {
      id: 'quadrantBackground',
      beforeDraw(chartInstance) {
        const { chartArea, ctx, scales } = chartInstance;
        if (!chartArea) return;
        const xScale = scales.x;
        const yScale = scales.y;
        const xZero = Math.min(Math.max(xScale.getPixelForValue(0), chartArea.left), chartArea.right);
        const yZero = Math.min(Math.max(yScale.getPixelForValue(0), chartArea.top), chartArea.bottom);

        const quadrants = [
          { key: 'positive-positive', xStart: xZero, xEnd: chartArea.right, yStart: chartArea.top, yEnd: yZero },
          { key: 'positive-negative', xStart: xZero, xEnd: chartArea.right, yStart: yZero, yEnd: chartArea.bottom },
          { key: 'negative-positive', xStart: chartArea.left, xEnd: xZero, yStart: chartArea.top, yEnd: yZero },
          { key: 'negative-negative', xStart: chartArea.left, xEnd: xZero, yStart: yZero, yEnd: chartArea.bottom },
        ];

        ctx.save();
        quadrants.forEach((quad) => {
          ctx.fillStyle = QUADRANT_BACKGROUND_COLORS[quad.key] || 'rgba(0, 0, 0, 0.03)';
          ctx.fillRect(quad.xStart, quad.yStart, quad.xEnd - quad.xStart, quad.yEnd - quad.yStart);
        });
        ctx.restore();
      }
    };

    function showStatus(message, variant = 'info') {
      statusEl.textContent = message;
      statusEl.style.display = 'block';
      statusEl.hidden = false;
      statusEl.style.borderColor = variant === 'error' ? '#f97316' : '#fed7aa';
      statusEl.style.background = variant === 'error' ? '#fff1f2' : '#fff7ed';
      statusEl.style.color = variant === 'error' ? '#9f1239' : '#9a3412';
    }

    function hideStatus() {
      statusEl.hidden = true;
      statusEl.textContent = '';
    }

    const PLAYOFF_LABELS = ['Super Bowl', 'Conf. Round', 'Divisional Round', 'Wild Card Round'];

    function formatWeekLabel(week, index, totalWeeks, season) {
      const isCurrentSeason = String(season) === String(new Date().getFullYear());
      if (isCurrentSeason) return `Week ${week}`;
      const offsetFromEnd = totalWeeks - 1 - index;
      const playoffLabel = PLAYOFF_LABELS[offsetFromEnd];
      if (playoffLabel) return playoffLabel;
      return `Week ${week}`;
    }

    function fillWeekSelect(selectEl, weeks, season) {
      selectEl.innerHTML = '';
      weeks.forEach((week, index) => {
        const option = document.createElement('option');
        option.value = week;
        option.textContent = formatWeekLabel(week, index, weeks.length, season);
        selectEl.appendChild(option);
      });
    }

    function averageWeeks(teamWeeks, start, end) {
      let offWeighted = 0;
      let offPlays = 0;
      let offSimple = 0;
      let defWeighted = 0;
      let defPlays = 0;
      let defSimple = 0;
      let count = 0;
      for (let w = start; w <= end; w += 1) {
        const payload = teamWeeks[w];
        if (payload && typeof payload.off === 'number' && typeof payload.def === 'number') {
          count += 1;
          offSimple += payload.off;
          defSimple += payload.def;
          const offWeekPlays = Number(payload.off_plays ?? 0);
          const defWeekPlays = Number(payload.def_plays ?? 0);
          if (Number.isFinite(offWeekPlays) && offWeekPlays > 0) {
            offWeighted += payload.off * offWeekPlays;
            offPlays += offWeekPlays;
          }
          if (Number.isFinite(defWeekPlays) && defWeekPlays > 0) {
            defWeighted += payload.def * defWeekPlays;
            defPlays += defWeekPlays;
          }
        }
      }
      if (count === 0) return null;
      const off = offPlays > 0 ? offWeighted / offPlays : offSimple / count;
      const def = defPlays > 0 ? defWeighted / defPlays : defSimple / count;
      return { off, def };
    }

    function computeRecord(season, team, startWeek, endWeek) {
      if (!season || !Array.isArray(season.games)) return null;
      const games = season.games.filter((g) => g.week >= startWeek && g.week <= endWeek && g.team === team);
      let wins = 0;
      let losses = 0;
      let ties = 0;
      let counted = 0;
      games.forEach((g) => {
        const pf = Number(g.points_for);
        const pa = Number(g.points_against);
        if (!Number.isFinite(pf) || !Number.isFinite(pa) || pf < 0 || pa < 0) return;
        counted += 1;
        if (pf > pa) wins += 1;
        else if (pf < pa) losses += 1;
        else ties += 1;
      });
      if (counted === 0) return null;
      const recordStr = ties ? `${wins}-${losses}-${ties}` : `${wins}-${losses}`;
      const winPct = (wins + 0.5 * ties) / counted;
      return { wins, losses, ties, recordStr, winPct };
    }

    function solveLinearSystem(matrix, vector) {
      const n = matrix.length;
      const augmented = matrix.map((row, idx) => [...row, vector[idx]]);
      for (let i = 0; i < n; i += 1) {
        let pivot = i;
        for (let r = i + 1; r < n; r += 1) {
          if (Math.abs(augmented[r][i]) > Math.abs(augmented[pivot][i])) pivot = r;
        }
        if (Math.abs(augmented[pivot][i]) < 1e-9) {
          console.error('SOS solver encountered a near-singular pivot');
          throw new Error('SOS solver failed due to singular matrix');
        }
        if (pivot !== i) [augmented[i], augmented[pivot]] = [augmented[pivot], augmented[i]];
        const pivotVal = augmented[i][i];
        for (let c = i; c <= n; c += 1) augmented[i][c] /= pivotVal;
        for (let r = 0; r < n; r += 1) {
          if (r === i) continue;
          const factor = augmented[r][i];
          if (factor === 0) continue;
          for (let c = i; c <= n; c += 1) augmented[r][c] -= factor * augmented[i][c];
        }
      }
      return augmented.map((row) => row[n]);
    }

    function computeSosRatingsForRange(selectedSeason, startWeek, endWeek, sosBasis = 'season_to_date') {
      const season = seasonData[selectedSeason];
      if (!season || !Array.isArray(season.games) || !season.games.length) {
        return { error: `No game rows in data for season ${selectedSeason}. Re-run backfill to populate team_epa_games and re-export.` };
      }

      let ratingGames;
      if (sosBasis === 'window_only') {
        ratingGames = season.games.filter((g) => g.week >= startWeek && g.week <= endWeek);
      } else if (sosBasis === 'full_season') {
        ratingGames = season.games;
      } else {
        ratingGames = season.games.filter((g) => g.week <= endWeek);
      }
      const displayGames = season.games.filter((g) => g.week >= startWeek && g.week <= endWeek);
      if (!ratingGames.length || !displayGames.length) {
        return { error: 'No game rows available for the selected SOS window.' };
      }

      const teams = Array.from(
        new Set([...ratingGames, ...displayGames].flatMap((g) => [g.team, g.opp])),
      ).sort();
      const idx = Object.fromEntries(teams.map((t, i) => [t, i]));
      const n = teams.length;
      const totalVars = n * 2;
      const lam = 20;
      const baseRow = Array.from({ length: totalVars }, (__unused, j) => 0);
      const AtA = Array.from({ length: totalVars }, (_, i) => baseRow.map((__, j) => (i === j ? lam : 0)));
      const Atb = Array(totalVars).fill(0);

      const offIndex = (team) => idx[team];
      const defIndex = (team) => idx[team] + n;

      let equationCount = 0;
      ratingGames.forEach((g) => {
        const t = g.team;
        const o = g.opp;
        const offWeight = Number(g.off_plays);
        const defWeight = Number(g.def_plays);
        const offVal = Number(g.off_epa_pp);
        const defVal = Number(g.def_epa_pp);

        if (Number.isFinite(offWeight) && offWeight > 0 && Number.isFinite(offVal)) {
          const tIdx = offIndex(t);
          const oIdx = defIndex(o);
          AtA[tIdx][tIdx] += offWeight;
          AtA[oIdx][oIdx] += offWeight;
          AtA[tIdx][oIdx] -= offWeight;
          AtA[oIdx][tIdx] -= offWeight;
          Atb[tIdx] += offWeight * offVal;
          Atb[oIdx] -= offWeight * offVal;
          equationCount += 1;
        }

        if (Number.isFinite(defWeight) && defWeight > 0 && Number.isFinite(defVal)) {
          const tIdx = defIndex(t);
          const oIdx = offIndex(o);
          AtA[tIdx][tIdx] += defWeight;
          AtA[oIdx][oIdx] += defWeight;
          AtA[tIdx][oIdx] -= defWeight;
          AtA[oIdx][tIdx] -= defWeight;
          Atb[tIdx] += defWeight * defVal;
          Atb[oIdx] -= defWeight * defVal;
          equationCount += 1;
        }
      });

      if (equationCount === 0) {
        return { error: 'No valid plays found to compute SOS for this range.' };
      }

      let ratingsArr;
      try {
        ratingsArr = solveLinearSystem(AtA, Atb);
      } catch (err) {
        console.warn('SOS solver failed; falling back to raw EPA for this selection', err);
        return { error: 'SOS solver failed due to singular matrix.' };
      }
      const mean = ratingsArr.reduce((acc, val) => acc + val, 0) / ratingsArr.length;
      const offRatings = {};
      const defRatings = {};
      teams.forEach((team, i) => {
        offRatings[team] = ratingsArr[i] - mean;
        defRatings[team] = ratingsArr[i + n] - mean;
      });

      const sosOffSums = {};
      const sosOffWeights = {};
      const sosDefSums = {};
      const sosDefWeights = {};
      displayGames.forEach((g) => {
        const offWeight = Number(g.off_plays);
        const defWeight = Number(g.def_plays);
        const oppDefRating = defRatings[g.opp];
        const oppOffRating = offRatings[g.opp];
        if (Number.isFinite(offWeight) && offWeight > 0 && Number.isFinite(oppDefRating)) {
          sosOffSums[g.team] = (sosOffSums[g.team] || 0) + offWeight * oppDefRating;
          sosOffWeights[g.team] = (sosOffWeights[g.team] || 0) + offWeight;
        }
        if (Number.isFinite(defWeight) && defWeight > 0 && Number.isFinite(oppOffRating)) {
          sosDefSums[g.team] = (sosDefSums[g.team] || 0) + defWeight * oppOffRating;
          sosDefWeights[g.team] = (sosDefWeights[g.team] || 0) + defWeight;
        }
      });

      const sosOffFaced = {};
      const sosDefFaced = {};
      teams.forEach((team) => {
        const offTotal = sosOffWeights[team] || 0;
        const defTotal = sosDefWeights[team] || 0;
        sosOffFaced[team] = offTotal ? sosOffSums[team] / offTotal : 0;
        sosDefFaced[team] = defTotal ? sosDefSums[team] / defTotal : 0;
      });

      return { offRatings, defRatings, sosOffFaced, sosDefFaced };
    }

    function buildTeamRows(selectedSeason, startWeek, endWeek, metricMode, sosBasis, sosData) {
      const season = seasonData[selectedSeason];
      if (!season) return [];
      return season.teams
        .map((teamEntry) => {
          const weeks = {};
          Object.entries(teamEntry.weeks).forEach(([week, values]) => {
            weeks[Number(week)] = values;
          });
          const averaged = averageWeeks(weeks, startWeek, endWeek);
          if (!averaged) return null;

          const baseOff = averaged.off;
          const baseDef = averaged.def;
          const sosOff = metricMode === 'sos' ? sosData?.sosOffFaced?.[teamEntry.team] : null;
          const sosDef = metricMode === 'sos' ? sosData?.sosDefFaced?.[teamEntry.team] : null;

          const offAdj = Number.isFinite(sosOff) ? baseOff + sosOff : baseOff;
          const defAdj = Number.isFinite(sosDef) ? baseDef + sosDef : baseDef;
          const combined = offAdj + defAdj;
          const record = computeRecord(season, teamEntry.team, startWeek, endWeek);

          return {
            x: offAdj,
            y: defAdj,
            label: teamEntry.team,
            backgroundColor: TEAM_COLORS[teamEntry.team] || '#0f172a',
            borderColor: '#0f172a',
            team: teamEntry.team,
            displayName: TEAM_DISPLAY_NAMES[teamEntry.team] || teamEntry.team,
            combined,
            off: offAdj,
            def: defAdj,
            rawCombined: baseOff + baseDef,
            rawOff: baseOff,
            rawDef: baseDef,
            deltaOff: offAdj - baseOff,
            deltaDef: defAdj - baseDef,
            sosOffFaced: Number.isFinite(sosOff) ? sosOff : null,
            sosDefFaced: Number.isFinite(sosDef) ? sosDef : null,
            wins: record?.wins ?? null,
            losses: record?.losses ?? null,
            ties: record?.ties ?? null,
            record: record?.recordStr ?? null,
            winPct: record?.winPct ?? null,
          };
        })
        .filter(Boolean);
    }

    function renderChart(points, seasonLabel, startWeek, endWeek, metricMode, sosBasis) {
      if (chart) chart.destroy();
      const subtitle = startWeek === endWeek ? `Week ${startWeek}` : `Weeks ${startWeek}\u2013${endWeek}`;
      const subtitleParts = [subtitle];
      if (metricMode === 'sos') {
        const basisLabel = sosBasis === 'full_season'
          ? 'full season'
          : sosBasis === 'window_only'
            ? 'window only'
            : `through Week ${endWeek}`;
        subtitleParts.push(`SOS-adjusted offense/defense EPA (opp basis: ${basisLabel})`);
      }
      const offenseAxisLabel = metricMode === 'sos'
        ? 'Offense EPA per play (SOS-adjusted via opponent defenses)'
        : 'Offense EPA per play (higher = better offense)';
      const defenseAxisLabel = metricMode === 'sos'
        ? 'Defense EPA per play (SOS-adjusted via opponent offenses)'
        : 'Defense EPA per play (higher = better defense)';

      chart = new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [{
          label: 'EPA per play',
          data: points,
          pointRadius: 12,
          pointHoverRadius: 14,
          backgroundColor: points.map((p) => p.backgroundColor),
          pointBackgroundColor: points.map((p) => p.backgroundColor),
          pointBorderColor: points.map((p) => p.borderColor),
          pointBorderWidth: 1.5,
        }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: 10 },
          plugins: {
            legend: { display: false },
            title: { display: false },
            subtitle: { display: true, text: subtitleParts.join(' ‚Äî ') },
            datalabels: {
              backgroundColor: null,
              borderWidth: 0,
              color: '#0f172a',
              formatter: (value) => value.label,
              font: { weight: 'bold', size: 11 },
              padding: { top: 2, bottom: 2, left: 2, right: 2 },
              textStrokeColor: '#fff',
              textStrokeWidth: 3,
            },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const { x, y, label } = ctx.raw;
                  const shiftedNote = metricMode === 'sos' ? ' (SOS-adjusted)' : '';
                  return `${label}: Off ${x.toFixed(3)}, Def ${y.toFixed(3)}${shiftedNote}`;
                },
              },
            },
          },
          scales: {
            x: {
              title: { display: true, text: offenseAxisLabel },
              grid: { color: '#e2e8f0' },
            },
            y: {
              title: { display: true, text: defenseAxisLabel },
              grid: { color: '#e2e8f0' },
            },
          },
        },
        plugins: [ChartDataLabels, quadrantPlugin],
      });
    }

    function syncWeekRange() {
      const start = Number(weekStartSelect.value);
      const end = Number(weekEndSelect.value);
      if (start > end) {
        weekEndSelect.value = start;
        return { start, end: start };
      }
      return { start, end };
    }

    function formatNumber(value) {
      return Number.isFinite(value) ? value.toFixed(3) : 'N/A';
    }

    function hexToRgb(hex) {
      const normalized = hex.replace('#', '');
      const bigint = parseInt(normalized, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255,
      };
    }

    function mixColors(start, end, t) {
      const startRgb = hexToRgb(start);
      const endRgb = hexToRgb(end);
      const clampT = Math.min(Math.max(t, 0), 1);
      const r = Math.round(startRgb.r + (endRgb.r - startRgb.r) * clampT);
      const g = Math.round(startRgb.g + (endRgb.g - startRgb.g) * clampT);
      const b = Math.round(startRgb.b + (endRgb.b - startRgb.b) * clampT);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function getRankColor(rank, totalTeams) {
      if (!Number.isFinite(rank) || totalTeams <= 1) return '#0f172a';
      const position = 1 - ((rank - 1) / Math.max(totalTeams - 1, 1));
      const red = '#ef4444';
      const gray = '#9ca3af';
      const green = '#22c55e';
      if (position <= 0.5) {
        return mixColors(red, gray, position / 0.5);
      }
      return mixColors(gray, green, (position - 0.5) / 0.5);
    }

    function computeRanks(rows, metricKey) {
      const sorted = [...rows].sort((a, b) => {
        const aVal = Number.isFinite(a[metricKey]) ? a[metricKey] : -Infinity;
        const bVal = Number.isFinite(b[metricKey]) ? b[metricKey] : -Infinity;
        if (bVal === aVal) return a.team.localeCompare(b.team);
        return bVal - aVal;
      });
      const rankMap = {};
      sorted.forEach((row, index) => {
        rankMap[row.team] = index + 1;
      });
      return rankMap;
    }

    function renderTable(rows, ranksByMetric = { combined: {}, off: {}, def: {}, sosOff: {}, sosDef: {} }, metricMode = 'raw') {
      tableBody.innerHTML = '';
      if (!rows.length) {
        tableBody.innerHTML = '<tr><td colspan="9">No EPA data for the selected range.</td></tr>';
        return;
      }
      const totalTeams = rows.length;
      const showRaw = metricMode === 'sos' && document.body.classList.contains('sos-mode');
      rows.forEach((row, index) => {
        const tr = document.createElement('tr');
        const combinedRank = ranksByMetric.combined[row.team];
        const offRank = ranksByMetric.off[row.team];
        const defRank = ranksByMetric.def[row.team];
        const sosOffRank = ranksByMetric.sosOff?.[row.team];
        const sosDefRank = ranksByMetric.sosDef?.[row.team];
        const sosOffValue = Number.isFinite(row.sosOffFaced) ? row.sosOffFaced.toFixed(6) : 'N/A';
        const sosDefValue = Number.isFinite(row.sosDefFaced) ? row.sosDefFaced.toFixed(6) : 'N/A';
        tr.innerHTML = `
          <td class="rank-cell" data-value="${index + 1}">${index + 1}</td>
          <td data-value="${row.team}">${row.displayName} (${row.team})</td>
          <td data-type="number" data-value="${Number.isFinite(row.winPct) ? row.winPct : ''}">${row.record ?? 'N/A'}</td>
          <td data-type="number" data-value="${Number.isFinite(row.winPct) ? row.winPct : ''}">${Number.isFinite(row.winPct) ? row.winPct.toFixed(3) : 'N/A'}</td>
          <td class="metric-cell" data-value="${row.combined.toFixed(6)}">
            <span class="metric-value">${formatNumber(row.combined)}</span>
            ${showRaw ? `<span class="raw-value">(raw ${formatNumber(row.rawCombined)})</span>` : ''}
            <span class="rank-label" style="color: ${getRankColor(combinedRank, totalTeams)}">(#${combinedRank})</span>
          </td>
          <td class="metric-cell sos-only" data-value="${sosOffValue}">
            <span class="metric-value">${Number.isFinite(row.sosOffFaced) ? formatNumber(row.sosOffFaced) : 'N/A'}</span>
            ${Number.isFinite(row.sosOffFaced)
              ? `<span class="rank-label" style="color: #0f172a">(#${sosOffRank})</span>`
              : ''}
          </td>
          <td class="metric-cell sos-only" data-value="${sosDefValue}">
            <span class="metric-value">${Number.isFinite(row.sosDefFaced) ? formatNumber(row.sosDefFaced) : 'N/A'}</span>
            ${Number.isFinite(row.sosDefFaced)
              ? `<span class="rank-label" style="color: #0f172a">(#${sosDefRank})</span>`
              : ''}
          </td>
          <td class="metric-cell" data-value="${row.off.toFixed(6)}">
            <span class="metric-value">${formatNumber(row.off)}</span>
            ${showRaw ? `<span class="raw-value">(raw ${formatNumber(row.rawOff)})</span>` : ''}
            <span class="rank-label" style="color: ${getRankColor(offRank, totalTeams)}">(#${offRank})</span>
          </td>
          <td class="metric-cell" data-value="${row.def.toFixed(6)}">
            <span class="metric-value">${formatNumber(row.def)}</span>
            ${showRaw ? `<span class="raw-value">(raw ${formatNumber(row.rawDef)})</span>` : ''}
            <span class="rank-label" style="color: ${getRankColor(defRank, totalTeams)}">(#${defRank})</span>
          </td>
        `;
        tableBody.appendChild(tr);
      });
      updateRankNumbers();
    }

    function updateRankNumbers() {
      Array.from(tableBody.querySelectorAll('tr')).forEach((row, index) => {
        const rankCell = row.querySelector('.rank-cell');
        if (rankCell) {
          rankCell.textContent = index + 1;
          rankCell.dataset.value = index + 1;
        }
      });
    }

    function getCellValue(cell, type) {
      const raw = cell.dataset.value ?? cell.textContent.trim();
      if (type === 'number') {
        const parsed = parseFloat(raw);
        return Number.isNaN(parsed) ? -Infinity : parsed;
      }
      return raw.toLowerCase();
    }

    function sortTable(columnIndex, toggle = true) {
      const header = tableHeaders[columnIndex];
      if (!header) return;

      const type = header.dataset.type || 'string';
      const isSameColumn = sortState.column === columnIndex;
      const direction = toggle
        ? (isSameColumn && sortState.direction === 'asc' ? 'desc' : 'asc')
        : (sortState.direction || 'asc');

      const rows = Array.from(tableBody.querySelectorAll('tr'));
      rows.sort((a, b) => {
        const aVal = getCellValue(a.children[columnIndex], type);
        const bVal = getCellValue(b.children[columnIndex], type);
        if (aVal === bVal) return 0;
        if (direction === 'asc') return aVal > bVal ? 1 : -1;
        return aVal < bVal ? 1 : -1;
      });

      tableBody.innerHTML = '';
      rows.forEach((row) => tableBody.appendChild(row));

      updateRankNumbers();

      tableHeaders.forEach((th) => th.classList.remove('sorted-asc', 'sorted-desc'));
      header.classList.add(direction === 'asc' ? 'sorted-asc' : 'sorted-desc');

      sortState.column = columnIndex;
      sortState.direction = direction;
    }

    tableHeaders.forEach((header, index) => {
      header.addEventListener('click', () => sortTable(index));
    });

    function refreshChart() {
      hideStatus();
      const season = seasonSelect.value;
      const { start, end } = syncWeekRange();
      const metricMode = metricModeSelect.value;
      const sosBasis = sosBasisSelect.value;
      const sosData = metricMode === 'sos'
        ? computeSosRatingsForRange(season, start, end, sosBasis)
        : null;
      const sosError = metricMode === 'sos' && sosData && sosData.error;
      const effectiveMetricMode = metricMode === 'sos' && (!sosData || sosError) ? 'raw' : metricMode;
      if (metricMode === 'sos' && (!sosData || sosError)) {
        const reason = sosError ? sosData.error : 'SOS metrics unavailable for this selection; showing raw EPA values instead.';
        showStatus(reason, 'error');
      }
      updateSosControlsVisibility(effectiveMetricMode);
      const rows = buildTeamRows(season, start, end, effectiveMetricMode, sosBasis, sosData);
      if (rows.length === 0) {
        showStatus('No EPA points available for that range. Try a different week selection.', 'error');
        if (chart) chart.destroy();
        renderTable([]);
        return;
      }
      const points = rows.map((row) => ({ x: row.x, y: row.y, label: row.label, backgroundColor: row.backgroundColor, borderColor: row.borderColor }));
      const ranksByMetric = {
        combined: computeRanks(rows, 'combined'),
        off: computeRanks(rows, 'off'),
        def: computeRanks(rows, 'def'),
        sosOff: effectiveMetricMode === 'sos' ? computeRanks(rows, 'sosOffFaced') : {},
        sosDef: effectiveMetricMode === 'sos' ? computeRanks(rows, 'sosDefFaced') : {},
      };
      renderChart(points, season, start, end, effectiveMetricMode, sosBasis);
      renderTable(rows, ranksByMetric, effectiveMetricMode);
      sortTable(sortState.column ?? 1, false);
    }

    function updateSosControlsVisibility(metricMode) {
      const wrap = document.getElementById('sos-basis-wrap');
      if (wrap) {
        wrap.style.display = metricMode === 'sos' ? '' : 'none';
      }
      document.body.classList.toggle('sos-mode', metricMode === 'sos');
    }

    function populateSeasonControls(seasonsMap) {
      seasonSelect.innerHTML = '';
      const sortedSeasonKeys = Object.keys(seasonsMap).sort();
      sortedSeasonKeys.forEach((seasonKey) => {
        const opt = document.createElement('option');
        opt.value = seasonKey;
        opt.textContent = seasonKey;
        seasonSelect.appendChild(opt);
      });
      const defaultSeason = sortedSeasonKeys[sortedSeasonKeys.length - 1];
      seasonSelect.value = defaultSeason;
      const selected = seasonsMap[seasonSelect.value];
      fillWeekSelect(weekStartSelect, selected.weeks, defaultSeason);
      fillWeekSelect(weekEndSelect, selected.weeks, defaultSeason);
      weekEndSelect.value = selected.weeks[selected.weeks.length - 1];
    }

    function setMetaText(snapshot) {
      const totalSeasons = Object.keys(snapshot.seasons || {}).length;
      const generatedAt = snapshot.generated_at || 'unknown';
      const sha = snapshot.git_sha ? snapshot.git_sha.slice(0, 7) : '';
      metaEl.textContent = totalSeasons
        ? `Loaded ${totalSeasons} seasons. generated_at=${generatedAt}${sha ? ` ¬∑ git=${sha}` : ''}`
        : '';
    }

    async function bootstrap() {
      try {
        const res = await fetch(DATA_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Failed to load data (${res.status})`);
        const json = await res.json();
        if (!json || typeof json !== 'object' || !json.seasons) {
          throw new Error('Unexpected JSON payload: missing seasons');
        }
        seasonData = json.seasons;
        if (!Object.keys(seasonData).length) throw new Error('No seasons found in data');
        setMetaText(json);
        populateSeasonControls(seasonData);
        refreshChart();
      } catch (err) {
        console.error(err);
        showStatus(`Unable to load data: ${err.message}`, 'error');
      }
    }

    seasonSelect.addEventListener('change', () => {
      const selected = seasonData[seasonSelect.value];
      if (!selected) return;
      fillWeekSelect(weekStartSelect, selected.weeks, seasonSelect.value);
      fillWeekSelect(weekEndSelect, selected.weeks, seasonSelect.value);
      weekEndSelect.value = selected.weeks[selected.weeks.length - 1];
      refreshChart();
    });

    weekStartSelect.addEventListener('change', () => syncWeekRange());
    weekEndSelect.addEventListener('change', () => syncWeekRange());
    metricModeSelect.addEventListener('change', () => {
      updateSosControlsVisibility(metricModeSelect.value);
      refreshChart();
    });
    sosBasisSelect.addEventListener('change', refreshChart);
    updateButton.addEventListener('click', refreshChart);
    updateSosControlsVisibility(metricModeSelect.value);
    bootstrap();
  </script>
</body>
</html>
