<!-- PATCH: fix defense sign convention (def_epa_pp is DEFENSE STRENGTH, higher=better) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NFL Weekly Matchups</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: light;
      --border: #e2e8f0;
      --text: #0f172a;
      --muted: #475569;
      --panel: #f8fafc;
      --pill-strong: #2563eb;
      --pill-slight: #0ea5e9;
      --pill-neutral: #94a3b8;
      --pill-def: #f97316;
      --neutral-edge: #cbd5e1;
    }

    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      color: var(--text);
      margin: 0;
      padding: 2rem 1.5rem 3rem;
      background: #ffffff;
    }

    main { max-width: 1100px; margin: 0 auto; }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    h1 { margin: 0 0 0.35rem; font-size: 1.9rem; }
    p.lead { margin: 0 0 0.65rem; color: var(--muted); }
    .meta { color: var(--muted); margin: 0 0 0.5rem; }

    .nav-actions {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: flex-end;
    }

    .hof-link {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.5rem 0.9rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: white;
      font-weight: 700;
      color: #0f172a;
      text-decoration: none;
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.08);
      transition: transform 120ms ease, box-shadow 120ms ease;
      white-space: nowrap;
    }

    .hof-link:hover { transform: translateY(-1px); box-shadow: 0 10px 18px rgba(15, 23, 42, 0.12); }

    .controls {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0 1.5rem;
    }

    label { font-weight: 600; display: block; margin-bottom: 0.25rem; }

    select, button {
      width: 100%;
      padding: 0.6rem 0.7rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
      background: white;
    }

    .toggle {
      display: inline-flex;
      gap: 0.5rem;
      align-items: center;
    }

    .toggle button {
      flex: 1;
      cursor: pointer;
      font-weight: 700;
      color: #0f172a;
      background: white;
      box-shadow: none;
      border: 1px solid var(--border);
    }

    .toggle button.active {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: white;
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.2);
      border: none;
    }

    .notice {
      background: #fff7ed;
      border: 1px solid #fed7aa;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
      color: #9a3412;
    }

    /* Give cards enough room for lane: label + dumbbell + badge without overflow/squish */
    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(min(420px, 100%), 1fr)); gap: 1rem; }
    .cards.ranked { grid-template-columns: 1fr; }

    .card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    .card-header { display: flex; justify-content: space-between; gap: 0.5rem; align-items: center; }
    .teams { font-weight: 700; font-size: 1.05rem; }
    .week-label { color: var(--muted); font-size: 0.95rem; }

    .scoreboard {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      padding: 0.85rem 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .game-summary {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .game-summary .summary-text {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      font-weight: 700;
    }

    .game-summary .drivers { color: var(--muted); font-weight: 600; font-size: 0.95rem; }

    .lane-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(min(280px, 100%), 1fr));
      gap: 0.6rem;
    }

    .lane {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 2fr) auto;
      gap: 0.65rem;
      padding: 0.65rem 0.75rem;
      align-items: center;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: white;
    }

    .lane-label { font-weight: 700; display: flex; flex-direction: column; gap: 0.15rem; min-width: 0; }
    .lane-label .sub { color: var(--muted); font-weight: 600; font-size: 0.95rem; }

    .edge-badge, .net-badge {
      display: inline-flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.1rem;
      padding: 0.5rem 0.7rem;
      border-radius: 10px;
      min-width: 120px;
      font-weight: 700;
      text-align: right;
      font-variant-numeric: tabular-nums;
      background: #fff;
      border: 1px solid var(--border);
      border-left: 8px solid var(--accent, var(--neutral-edge));
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.06);
      color: var(--text);
    }

    .net-badge { align-items: flex-start; min-width: 140px; }

    .edge-badge .value, .net-badge .value { font-size: 1.1rem; line-height: 1.1; color: var(--accentText, var(--text)); }
    .edge-badge .badge-sub, .net-badge .badge-sub { font-size: 0.9rem; color: var(--muted); font-weight: 600; }

    .legend { color: var(--muted); margin: 0 0 1rem; font-size: 0.95rem; }

    .details { font-size: 0.9rem; color: var(--muted); }
    .details summary { cursor: pointer; font-weight: 600; }
    .details div { margin-top: 0.35rem; line-height: 1.3; }

    .odds { color: var(--muted); font-size: 0.95rem; display: flex; justify-content: space-between; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    .odds .odds-meta { flex-basis: 100%; font-size: 0.9rem; color: var(--muted); }

    .empty { text-align: center; color: var(--muted); border: 1px dashed var(--border); border-radius: 12px; padding: 1rem; }

    /* Dumbbell */
    .db { width: 100%; }
    .db-wrap { display: flex; flex-direction: column; gap: 0.3rem; }
    .db-labels { display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: var(--muted); gap: 0.5rem; }
    .db-label { display: inline-flex; align-items: center; gap: 0.35rem; min-width: 0; white-space: nowrap; }
    .db-label span:last-child { overflow: hidden; text-overflow: ellipsis; }
    .db-key { display: inline-block; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(15, 23, 42, 0.18); }
    .db-key.off { background: var(--offColor); border-color: white; }
    .db-key.def { background: white; border: 2px solid var(--defColor); }
    .db-viz { position: relative; width: 100%; min-width: 0; height: 22px; background: white; border: 1px solid var(--border); border-radius: 999px; padding: 2px 10px; }
    .db-inner { position: relative; width: 100%; height: 100%; }
    .db-track { position: absolute; inset: 4px 0; background: var(--panel); border-radius: 999px; }
    .db-zero { position: absolute; top: 2px; width: 2px; height: 18px; background: var(--border); transform: translateX(-50%); }
    .db-range { position: absolute; top: 6px; height: 10px; background: linear-gradient(90deg, var(--offColor), var(--defColor)); border-radius: 999px; opacity: 0.9; }
    .db-dot { position: absolute; top: 50%; width: 18px; height: 18px; border-radius: 50%; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.15); transform: translate(-50%, -50%); }
    .db-dot.off { background: var(--offColor); border: 2px solid white; }
    .db-dot.def { background: #fff; border: 3px solid var(--defColor); }
    .db-placeholder { position: absolute; inset: 0; display: grid; place-items: center; font-size: 0.85rem; color: var(--muted); background: rgba(226, 232, 240, 0.4); border-radius: 999px; }

    @media (max-width: 640px) {
      body { padding: 1.5rem 1rem 2.5rem; }
      .controls { grid-template-columns: 1fr; }
      .lane { grid-template-columns: 1fr; }
      .lane-label { flex-direction: row; justify-content: space-between; align-items: center; }
      .edge-badge { align-items: flex-start; }
      .db-viz { min-width: 0; }
    }

    @media (max-width: 800px) {
      .db { min-width: 0; }
      .db-viz { width: 100%; min-width: 0; }
    }
  </style>
</head>
<body>
  <main>
    <div class="top-bar">
      <div>
        <h1>Weekly Matchups</h1>
        <p class="lead">Offense vs defense EPA/play edges for every game. Toggle raw vs opponent-adjusted views and pick any week.</p>
        <p id="meta" class="meta"></p>
      </div>
      <div class="nav-actions">
        <a class="hof-link" href="index.html" aria-label="Back to EPA chart">‚¨ÖÔ∏è Back</a>
        <a class="hof-link" href="hof.html" aria-label="View EPA Hall of Fame">üèÜ HOF</a>
      </div>
    </div>

    <div id="status" class="notice" hidden></div>

    <section class="controls">
      <div>
        <label for="season-select">Season</label>
        <select id="season-select"></select>
      </div>
      <div>
        <label for="week-select">Week</label>
        <select id="week-select"></select>
      </div>
      <fieldset style="border: none; padding: 0; margin: 0;">
        <legend style="font-weight: 600; margin-bottom: 0.25rem; padding: 0;">View</legend>
        <div class="toggle" role="group" aria-label="Raw vs opponent-adjusted">
          <button id="raw-btn" class="active" type="button">Raw</button>
          <button id="sos-btn" type="button">Opponent-adjusted</button>
        </div>
      </fieldset>
      <fieldset style="border: none; padding: 0; margin: 0;">
        <legend style="font-weight: 600; margin-bottom: 0.25rem; padding: 0;">Layout</legend>
        <div class="toggle" role="group" aria-label="Games vs ranked list">
          <button id="games-btn" class="active" type="button">Games</button>
          <button id="ranked-btn" type="button">Ranked</button>
        </div>
      </fieldset>
    </section>

    <p class="legend">Filled dot = offense EPA/play (team color). Ring dot = opponent defense strength (team color). Edge: <strong>+</strong> favors offense, <strong>‚àí</strong> favors defense. <strong>Pxx</strong> = percentile of strength this week (NET for game badge; lane |Edge| in Ranked view). ‚âà points uses EPA/play √ó 65. Rank (#/N) is shown in Ranked view.</p>

    <div id="cards" class="cards" aria-live="polite"></div>
  </main>

  <script>
    const statusEl = document.getElementById('status');
    const metaEl = document.getElementById('meta');
    const seasonSelect = document.getElementById('season-select');
    const weekSelect = document.getElementById('week-select');
    const cardsEl = document.getElementById('cards');
    const rawBtn = document.getElementById('raw-btn');
    const sosBtn = document.getElementById('sos-btn');
    const gamesBtn = document.getElementById('games-btn');
    const rankedBtn = document.getElementById('ranked-btn');

    const DATA_URL = new URL('data/epa.json', document.baseURI);
    const SCHEDULE_URL = new URL('data/schedule.json', document.baseURI);
    const ODDS_URL = new URL('data/odds.json', document.baseURI);
    const urlParams = new URLSearchParams(window.location.search);

    const PLAYS_PER_GAME = 65;

    const TEAM_COLORS = {
      ARI: '#97233F', ATL: '#A71930', BAL: '#241773', BUF: '#00338D', CAR: '#0085CA', CHI: '#0B162A',
      CIN: '#FB4F14', CLE: '#311D00', DAL: '#003594', DEN: '#FB4F14', DET: '#0076B6', GB: '#203731',
      HOU: '#03202F', IND: '#002C5F', JAX: '#101820', KC: '#E31837', LAC: '#0080C6', LAR: '#003594',
      LV: '#000000', MIA: '#008E97', MIN: '#4F2683', NE: '#002244', NO: '#D3BC8D', NYG: '#0B2265',
      NYJ: '#125740', PHI: '#004C54', PIT: '#101820', SEA: '#002244', SF: '#AA0000', TB: '#D50A0A',
      TEN: '#4B92DB', WAS: '#5A1414'
    };

    // Common aliases (data sources vary)
    TEAM_COLORS.WSH = TEAM_COLORS.WAS;
    TEAM_COLORS.JAC = TEAM_COLORS.JAX;
    TEAM_COLORS.OAK = TEAM_COLORS.LV;
    TEAM_COLORS.SD  = TEAM_COLORS.LAC;
    TEAM_COLORS.STL = TEAM_COLORS.LAR;
    TEAM_COLORS.LA  = TEAM_COLORS.LAR;

    const TEAM_ALIASES = { WSH: 'WAS', JAC: 'JAX', OAK: 'LV', SD: 'LAC', STL: 'LAR', LA: 'LAR' };

    function normalizeTeam(code) {
      const value = String(code || '').trim().toUpperCase();
      return TEAM_ALIASES[value] || value;
    }

    function normalizeOdds(payload) {
      if (Array.isArray(payload?.odds)) return payload;
      return { odds: [] };
    }

    // If EPA data only contains completed games, future weeks (e.g., Week 18) won't exist.
    // Use odds.json as a lightweight schedule source to add placeholder games.
    function _parseIntLoose(value) {
      const n = Number(value);
      if (Number.isFinite(n)) return n;
      const m = String(value ?? '').match(/(\d+)/);
      return m ? Number(m[1]) : NaN;
    }

    function parseGameId(gameId) {
      const parts = String(gameId ?? '').split('_');
      // Expected: SEASON_WEEK_TEAM_TEAM (e.g., 2025_18_BUF_MIA or 2025_WC_BUF_MIA)
      if (parts.length < 4) return null;
      const season = _parseIntLoose(parts[0]);
      const weekToken = parts[1];
      const week = normalizeWeekValue(weekToken, season, null);
      const teamA = parts[2];
      const teamB = parts[3];
      if (!Number.isFinite(season) || !Number.isFinite(week) || !teamA || !teamB) return null;
      return { season, week, teamA, teamB };
    }

    let data;
    let schedulePayload = null;
    let oddsPayload = null;
    let oddsIndex = {};
    let mode = 'raw';
    let layoutMode = localStorage.getItem('layoutMode') || 'games';
    if (!['games', 'ranked'].includes(layoutMode)) layoutMode = 'games';
    let userSelectedWeek = false;

    function showStatus(message, variant = 'info') {
      statusEl.textContent = message;
      statusEl.hidden = false;
      statusEl.style.display = 'block';
      statusEl.style.borderColor = variant === 'error' ? '#f97316' : '#fed7aa';
      statusEl.style.background = variant === 'error' ? '#fff1f2' : '#fff7ed';
      statusEl.style.color = variant === 'error' ? '#9f1239' : '#9a3412';
    }

    function hideStatus() {
      statusEl.hidden = true;
      statusEl.textContent = '';
    }

    const PLAYOFF_ROUND_ORDER = {
      WC: 1,
      WILDCARD: 1,
      'WILD CARD': 1,
      DIV: 2,
      DIVISIONAL: 2,
      CONF: 3,
      CONFERENCE: 3,
      CHAMP: 3,
      'CONFERENCE CHAMPIONSHIP': 3,
      SB: 4,
      'SUPER BOWL': 4,
      SUPERBOWL: 4,
    };

    const REG_MAX_BY_SEASON = {};

    function computeRegMaxBySeasonFromSchedule() {
      Object.keys(REG_MAX_BY_SEASON).forEach((k) => delete REG_MAX_BY_SEASON[k]);

      // Support either {schedules:[...]} or {seasons:{ "2025": {games:[...] }}}
      const schedules = Array.isArray(schedulePayload?.schedules)
        ? schedulePayload.schedules
        : Object.entries(schedulePayload?.seasons || {}).map(([season, sched]) => ({
            season,
            games: sched?.games || [],
          }));

      schedules.forEach((sched) => {
        const seasonNum = Number(sched?.season);
        if (!Number.isFinite(seasonNum)) return;

        let max = 0;
        (sched?.games || []).forEach((g) => {
          // Exclude postseason games from the "regular season max"
          const seasonTypeRaw = (g?.season_type ?? g?.seasonType ?? '');
          const seasonType = String(seasonTypeRaw).trim().toUpperCase();
          const gameTypeRaw = (g?.game_type ?? g?.gameType ?? '');
          const gameType = String(gameTypeRaw).trim().toUpperCase();
          const isPost = g?.postseason === true
            || seasonType === 'POST'
            || seasonType === 'POSTSEASON'
            || seasonType === '2'
            || (gameType in PLAYOFF_ROUND_ORDER);
          if (isPost) return;

          const w = Number(String(g?.week ?? '').trim());
          if (!Number.isFinite(w) || w <= 0) return;
          if (w <= 18) max = Math.max(max, w);
        });

        if (max > 0) REG_MAX_BY_SEASON[String(seasonNum)] = max;
      });
    }

    function normalizeWeekValue(weekValue, seasonNum = null, seasonType = null) {
      const raw = String(weekValue ?? '').trim();
      if (!raw) return NaN;

      const seasonKey = seasonNum != null ? String(seasonNum) : null;
      const base = seasonKey && Number.isFinite(REG_MAX_BY_SEASON[seasonKey]) ? REG_MAX_BY_SEASON[seasonKey] : 18;

      const st = String(seasonType ?? '').trim().toUpperCase();
      const asNum = Number(raw);
      if (Number.isFinite(asNum)) {
        if (asNum <= 0) return NaN;
        // If postseason is encoded as round numbers 1-4, lift them above regular season.
        if ((st === 'POST' || st === 'POSTSEASON' || st === '2') && asNum >= 1 && asNum <= 4) {
          return base + asNum;
        }
        return asNum;
      }

      const order = PLAYOFF_ROUND_ORDER[raw.toUpperCase()];
      if (order) return base + order;

      return NaN;
    }

    function formatWeekLabel(value, seasonNum = null) {
      if (!Number.isFinite(value)) return 'Week ?';
      const seasonKey = seasonNum != null ? String(seasonNum) : null;
      const base = seasonKey && REG_MAX_BY_SEASON[seasonKey] ? REG_MAX_BY_SEASON[seasonKey] : null;
      if (base) {
        const delta = value - base;
        if (delta === 1) return 'WC';
        if (delta === 2) return 'DIV';
        if (delta === 3) return 'CONF';
        if (delta === 4) return 'SB';
      }
      return `Week ${value}`;
    }

    function getSeasonWeeks(season, seasonKey = null) {
      const weeks = [];
      const seasonNum = Number(seasonKey);
      (season?.weeks || []).forEach((w) => weeks.push(normalizeWeekValue(w, seasonNum)));
      (season?.games || []).forEach((g) => weeks.push(normalizeWeekValue(g.week, seasonNum, g?.season_type)));
      return Array.from(new Set(weeks.filter((w) => Number.isFinite(w)))).sort((a, b) => a - b);
    }

    function getCurrentWeek(season, seasonKey = null) {
      const weeks = getSeasonWeeks(season, seasonKey);
      return weeks.length ? weeks[weeks.length - 1] : 1;
    }

    function getWeekOverride(weeks, seasonKey = null) {
      const seasonNum = Number(seasonKey);
      const override = normalizeWeekValue(urlParams.get('week'), seasonNum);
      if (!Number.isFinite(override)) return null;
      const weekSet = new Set((weeks || []).map((w) => normalizeWeekValue(w, seasonNum)).filter((w) => Number.isFinite(w)));
      return weekSet.has(override) ? override : null;
    }

    function fillSelect(selectEl, values, seasonNum = null) {
      selectEl.innerHTML = '';
      values.forEach((val) => {
        const option = document.createElement('option');
        option.value = val;
        option.textContent = formatWeekLabel(val, seasonNum);
        selectEl.appendChild(option);
      });
    }

    async function fetchSchedule() {
      try {
        const scheduleUrl = new URL(SCHEDULE_URL);
        scheduleUrl.searchParams.set('v', String(Date.now()));
        const res = await fetch(scheduleUrl, { cache: 'no-store' });
        if (!res.ok) throw new Error('Failed to load schedule');
        schedulePayload = await res.json();
      } catch (err) {
        schedulePayload = null;
        console.warn('Schedule not available', err);
      }
    }

    function mergeScheduleIntoData() {
      if (!data || !schedulePayload) return;
      const scheduleSeasons = schedulePayload.seasons || {};
      Object.entries(scheduleSeasons).forEach(([seasonKey, sched]) => {
        if (!data.seasons) data.seasons = {};
        if (!data.seasons[seasonKey]) data.seasons[seasonKey] = { weeks: [], games: [] };
        const season = data.seasons[seasonKey];
        if (!Array.isArray(season.games)) season.games = [];

        const matchupKey = (team, opp, week) => `${normalizeWeekValue(week, seasonKey)}::${team}::${opp}`;
        const existingMatchups = new Set();
        (season.games || []).forEach((g) => {
          const team = normalizeTeam(g.team || g.home || g.away);
          const oppGuess = g.opp || (team && (g.home || g.away)
            ? (team === normalizeTeam(g.home) ? g.away : g.home)
            : '');
          const opp = normalizeTeam(oppGuess);
          const week = normalizeWeekValue(g.week, seasonKey, g?.season_type);
          if (!team || !opp || !Number.isFinite(week)) return;
          existingMatchups.add(matchupKey(team, opp, week));
        });

        (sched?.games || []).forEach((g) => {
          const week = normalizeWeekValue(g.week, seasonKey, g?.season_type);
          const gameId = g.game_id;
          const home = normalizeTeam(g.home);
          const away = normalizeTeam(g.away);
          if (!gameId || !Number.isFinite(week) || !home || !away) return;

          const entries = [
            { game_id: gameId, week, team: home, opp: away },
            { game_id: gameId, week, team: away, opp: home },
          ];

          entries.forEach((entry) => {
            const key = matchupKey(entry.team, entry.opp, entry.week);
            if (existingMatchups.has(key)) return;
            season.games.push(entry);
            existingMatchups.add(key);
          });
        });
      });
    }

    function _rowKey(gameId, week, team, seasonNum = null, seasonType = null) {
      const w = normalizeWeekValue(week, seasonNum, seasonType);
      const t = normalizeTeam(team);
      return `${String(gameId)}::${String(w)}::${t}`;
    }

    function _recomputeWeeksFromGames(season, seasonNum = null) {
      const weeks = Array.from(new Set(
        (season.games || [])
          .map((g) => normalizeWeekValue(g.week, seasonNum, g?.season_type))
          .filter((w) => Number.isFinite(w))
      )).sort((a, b) => a - b);
      season.weeks = weeks;
    }

    function _ensureSeason(seasonKey) {
      if (!data.seasons) data.seasons = {};
      if (!data.seasons[seasonKey]) data.seasons[seasonKey] = { weeks: [], games: [] };
      if (!Array.isArray(data.seasons[seasonKey].games)) data.seasons[seasonKey].games = [];
      if (!Array.isArray(data.seasons[seasonKey].weeks)) data.seasons[seasonKey].weeks = [];
      return data.seasons[seasonKey];
    }

    function mergeOddsScheduleIntoData() {
      if (!data || !oddsPayload) return;
      if (!data.seasons) data.seasons = {};

      const seenBySeason = {};

      Object.entries(data.seasons).forEach(([seasonKey, season]) => {
        const seen = new Set();
        if (!Array.isArray(season.games)) season.games = [];
        season.games.forEach((g) => {
          const gid = g?.game_id;
          const week = normalizeWeekValue(g?.week, seasonKey, g?.season_type);
          const team = normalizeTeam(g?.team || g?.home || g?.away);
          if (!gid || !Number.isFinite(week) || !team) return;
          seen.add(_rowKey(gid, week, team, seasonKey, g?.season_type));
        });
        seenBySeason[seasonKey] = seen;
      });

      (oddsPayload.odds || []).forEach((o) => {
        const gameId = o?.game_id || o?.gameId;
        const parsed = parseGameId(gameId);
        const seasonNum = Number.isFinite(_parseIntLoose(o?.season)) ? _parseIntLoose(o?.season) : parsed?.season;
        const rawWeek = Number.isFinite(_parseIntLoose(o?.week)) ? _parseIntLoose(o?.week) : parsed?.week;
        const weekNum = normalizeWeekValue(rawWeek, seasonNum, o?.season_type);
        const teamA = normalizeTeam(parsed?.teamA);
        const teamB = normalizeTeam(parsed?.teamB);

        if (!Number.isFinite(seasonNum) || !Number.isFinite(weekNum) || !teamA || !teamB) return;
        const seasonKey = String(seasonNum);
        const season = _ensureSeason(seasonKey);
        if (!Array.isArray(season.games)) season.games = [];
        if (!Array.isArray(season.weeks)) season.weeks = [];
        if (!season.weeks.includes(weekNum)) season.weeks.push(weekNum);

        if (!seenBySeason[seasonKey]) seenBySeason[seasonKey] = new Set();
        const seen = seenBySeason[seasonKey];
        const keyA = _rowKey(gameId, weekNum, teamA, seasonNum, o?.season_type);
        const keyB = _rowKey(gameId, weekNum, teamB, seasonNum, o?.season_type);
        // Add missing directions independently (important for repairing one-sided games)
        if (!seen.has(keyA)) {
          season.games.push({ game_id: gameId, week: weekNum, team: teamA, opp: teamB, _placeholder: true });
          seen.add(keyA);
        }
        if (!seen.has(keyB)) {
          season.games.push({ game_id: gameId, week: weekNum, team: teamB, opp: teamA, _placeholder: true });
          seen.add(keyB);
        }
      });
    }

    // Hard guarantee: every scheduled game results in TWO rows (team + opponent).
    // This prevents "missing a ton of games" when only one side exists in season.games.
    function repairGamesFromScheduleAndOdds() {
      if (!data) return;
      if (!data.seasons) data.seasons = {};

      // Build a per-season set of existing rows by (game_id, week, team)
      const existingBySeason = {};
      Object.entries(data.seasons).forEach(([seasonKey, season]) => {
        if (!Array.isArray(season.games)) season.games = [];
        const set = new Set();
        season.games.forEach((g) => {
          const gid = g?.game_id;
          const week = normalizeWeekValue(g?.week, seasonKey, g?.season_type);
          const team = normalizeTeam(g?.team || g?.home || g?.away);
          if (!gid || !Number.isFinite(week) || !team) return;
          set.add(_rowKey(gid, week, team, seasonKey, g?.season_type));
        });
        existingBySeason[seasonKey] = set;
      });

      // 1) Repair from schedulePayload (authoritative home/away)
      const schedules = Array.isArray(schedulePayload?.schedules)
        ? schedulePayload.schedules
        : Object.entries(schedulePayload?.seasons || {}).map(([season, sched]) => ({
            season,
            games: sched?.games || [],
          }));
      schedules.forEach((sched) => {
        const seasonNum = _parseIntLoose(sched?.season);
        if (!Number.isFinite(seasonNum)) return;
        const seasonKey = String(seasonNum);
        const season = _ensureSeason(seasonKey);
        if (!existingBySeason[seasonKey]) existingBySeason[seasonKey] = new Set();
        const seen = existingBySeason[seasonKey];

        (sched?.games || []).forEach((g) => {
          const gid = g?.game_id;
          const week = normalizeWeekValue(g?.week, seasonNum, g?.season_type);
          const home = normalizeTeam(g?.home);
          const away = normalizeTeam(g?.away);
          if (!gid || !Number.isFinite(week) || !home || !away) return;

          const kHome = _rowKey(gid, week, home, seasonNum, g?.season_type);
          const kAway = _rowKey(gid, week, away, seasonNum, g?.season_type);

          if (!seen.has(kHome)) {
            season.games.push({ game_id: gid, week, team: home, opp: away, _placeholder: true });
            seen.add(kHome);
          }
          if (!seen.has(kAway)) {
            season.games.push({ game_id: gid, week, team: away, opp: home, _placeholder: true });
            seen.add(kAway);
          }
        });
      });

      // 2) Repair from oddsPayload (backup; uses game_id parsing)
      (oddsPayload?.odds || []).forEach((o) => {
        const gameId = o?.game_id || o?.gameId;
        const parsed = parseGameId(gameId);
        const seasonNum = Number.isFinite(_parseIntLoose(o?.season)) ? _parseIntLoose(o?.season) : parsed?.season;
        const rawWeek = Number.isFinite(_parseIntLoose(o?.week)) ? _parseIntLoose(o?.week) : parsed?.week;
        const week = normalizeWeekValue(rawWeek, seasonNum, o?.season_type);
        const teamA = normalizeTeam(parsed?.teamA);
        const teamB = normalizeTeam(parsed?.teamB);
        if (!gameId || !Number.isFinite(seasonNum) || !Number.isFinite(week) || !teamA || !teamB) return;

        const seasonKey = String(seasonNum);
        const season = _ensureSeason(seasonKey);
        if (!existingBySeason[seasonKey]) existingBySeason[seasonKey] = new Set();
        const seen = existingBySeason[seasonKey];

        const kA = _rowKey(gameId, week, teamA, seasonNum, o?.season_type);
        const kB = _rowKey(gameId, week, teamB, seasonNum, o?.season_type);
        if (!seen.has(kA)) {
          season.games.push({ game_id: gameId, week, team: teamA, opp: teamB, _placeholder: true });
          seen.add(kA);
        }
        if (!seen.has(kB)) {
          season.games.push({ game_id: gameId, week, team: teamB, opp: teamA, _placeholder: true });
          seen.add(kB);
        }
      });

      // Recompute weeks from games so the dropdown can‚Äôt "lose" weeks.
      Object.entries(data.seasons).forEach(([seasonKey, season]) => _recomputeWeeksFromGames(season, Number(seasonKey)));
    }

    function groupGamesForWeek(season, week, seasonKey = null) {
      const byId = {};
      const normalizedWeek = normalizeWeekValue(week, seasonKey);
      if (!Number.isFinite(normalizedWeek)) return [];

      (season.games || []).forEach((g) => {
        const gameId = g.game_id;
        const gameWeek = normalizeWeekValue(g.week, seasonKey, g?.season_type);
        if (!gameId || gameWeek !== normalizedWeek) return;
        const team = normalizeTeam(g.team || g.home || g.away);
        const oppGuess = g.opp || (team && (g.home || g.away)
          ? (team === normalizeTeam(g.home) ? g.away : g.home)
          : '');
        const opp = normalizeTeam(oppGuess);
        if (!team || !opp) return;

        const enriched = { ...g, team, opp };
        if (!byId[gameId]) {
          byId[gameId] = { game_id: gameId, teams: [] };
        }
        byId[gameId].teams.push(enriched);
      });
      return Object.values(byId);
    }

    function computeTeamAggregates(season, week, seasonKey = null) {
      const aggregates = {};
      const includeGame = (g, limit) => {
        const gameWeek = normalizeWeekValue(g.week, seasonKey, g?.season_type);
        const limitWeek = normalizeWeekValue(limit, seasonKey);
        if (!Number.isFinite(gameWeek) || !Number.isFinite(limitWeek)) return false;
        return gameWeek < limitWeek;
      };

      const addGame = (g) => {
        const team = normalizeTeam(g.team || g.home || g.away);
        if (!team) return;
        if (!aggregates[team]) {
          aggregates[team] = { offSum: 0, offPlays: 0, defSum: 0, defPlays: 0 };
        }
        const entry = aggregates[team];
        if (Number.isFinite(g.off_epa_pp) && Number.isFinite(g.off_plays)) {
          entry.offSum += g.off_epa_pp * g.off_plays;
          entry.offPlays += g.off_plays;
        }
        if (Number.isFinite(g.def_epa_pp) && Number.isFinite(g.def_plays)) {
          entry.defSum += g.def_epa_pp * g.def_plays;
          entry.defPlays += g.def_plays;
        }
      };

      (season.games || []).forEach((g) => {
        if (includeGame(g, week)) addGame(g);
      });

      const ratings = {};
      Object.entries(aggregates).forEach(([team, entry]) => {
        const offEPA = entry.offPlays > 0 ? entry.offSum / entry.offPlays : null;
        const defEPA = entry.defPlays > 0 ? entry.defSum / entry.defPlays : null;
        ratings[team] = {
          offEPA,
          defEPA,
          offPlays: entry.offPlays,
          defPlays: entry.defPlays,
        };
      });
      return ratings;
    }

    function computeSOSAdjustedRatings(season, week, baseRatings, seasonKey = null) {
      const totals = { offEpaSum: 0, offPlays: 0, defEpaSum: 0, defPlays: 0 };
      Object.values(baseRatings).forEach((entry) => {
        if (Number.isFinite(entry.offEPA)) {
          totals.offEpaSum += entry.offEPA * entry.offPlays;
          totals.offPlays += entry.offPlays;
        }
        if (Number.isFinite(entry.defEPA)) {
          totals.defEpaSum += entry.defEPA * entry.defPlays;
          totals.defPlays += entry.defPlays;
        }
      });

      const leagueAvgOffEPA = totals.offPlays ? totals.offEpaSum / totals.offPlays : 0;
      const leagueAvgDefEPA = totals.defPlays ? totals.defEpaSum / totals.defPlays : 0;

      const opponentFacings = {};
      (season.games || []).forEach((g) => {
        const gameWeek = normalizeWeekValue(g.week, seasonKey ?? season?.season, g?.season_type);
        const limitWeek = normalizeWeekValue(week, seasonKey ?? season?.season);
        if (!Number.isFinite(gameWeek) || !Number.isFinite(limitWeek) || gameWeek >= limitWeek) return;
        const team = normalizeTeam(g.team || g.home || g.away);
        const oppGuess = g.opp || (team && (g.home || g.away)
          ? (team === normalizeTeam(g.home) ? g.away : g.home)
          : '');
        const opp = normalizeTeam(oppGuess);
        if (!team || !opp) return;
        if (!opponentFacings[team]) {
          opponentFacings[team] = { oppOffEpa: 0, oppDefEpa: 0, offPlays: 0, defPlays: 0 };
        }
        const oppRatings = baseRatings[opp];
        if (!oppRatings) return;
        const facing = opponentFacings[team];
        if (Number.isFinite(g.off_plays) && Number.isFinite(oppRatings.defEPA)) {
          facing.offPlays += g.off_plays;
          facing.oppDefEpa += g.off_plays * oppRatings.defEPA;
        }
        if (Number.isFinite(g.def_plays) && Number.isFinite(oppRatings.offEPA)) {
          facing.defPlays += g.def_plays;
          facing.oppOffEpa += g.def_plays * oppRatings.offEPA;
        }
      });

      const adjusted = {};
      // NOTE: def_epa_pp in this repo is DEFENSE STRENGTH (sign-flipped in the pipeline so higher = better defense).
      // Opponent-adjusted (one-pass) EPA:
      //   OffEPA_adj = OffEPA + avgOppDefEPA - leagueAvgDefEPA
      //   DefEPA_adj = DefEPA + avgOppOffEPA - leagueAvgOffEPA
      Object.entries(baseRatings).forEach(([team, entry]) => {
        const facing = opponentFacings[team] || {};
        const avgOppDefEPA = facing.offPlays ? facing.oppDefEpa / facing.offPlays : leagueAvgDefEPA;
        const avgOppOffEPA = facing.defPlays ? facing.oppOffEpa / facing.defPlays : leagueAvgOffEPA;

        const adjOffEPA = Number.isFinite(entry.offEPA)
          ? entry.offEPA + avgOppDefEPA - leagueAvgDefEPA
          : null;
        const adjDefEPA = Number.isFinite(entry.defEPA)
          ? entry.defEPA + avgOppOffEPA - leagueAvgOffEPA
          : null;

        adjusted[team] = {
          ...entry,
          adjOffEPA,
          adjDefEPA,
        };
      });

      return adjusted;
    }

    function teamColor(team) {
      const id = String(team || '').toUpperCase().trim();
      return TEAM_COLORS[id] || '#0f172a';
    }

    function hexToRgb(hex) {
      const normalized = hex.replace('#', '').trim();
      if (![3, 6].includes(normalized.length)) return null;
      const value = normalized.length === 3
        ? normalized.split('').map((c) => parseInt(c.repeat(2), 16))
        : [normalized.slice(0, 2), normalized.slice(2, 4), normalized.slice(4, 6)].map((c) => parseInt(c, 16));
      if (value.some((v) => Number.isNaN(v))) return null;
      return { r: value[0], g: value[1], b: value[2] };
    }

    function relativeLuminance(hex) {
      const rgb = hexToRgb(hex);
      if (!rgb) return null;
      const channel = (v) => {
        const c = v / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      };
      return 0.2126 * channel(rgb.r) + 0.7152 * channel(rgb.g) + 0.0722 * channel(rgb.b);
    }

    function accentTextColor(hex) {
      const lum = relativeLuminance(hex);
      if (!Number.isFinite(lum)) return hex;
      return lum > 0.55 ? '#0f172a' : hex;
    }

    function epaToPoints(epa) {
      return Number.isFinite(epa) ? epa * PLAYS_PER_GAME : null;
    }

    function formatSigned(val, digits = 2) {
      if (!Number.isFinite(val)) return '‚Äî';
      const rounded = val.toFixed(digits);
      if (Number(rounded) === 0) return '0.00';
      return `${val > 0 ? '+' : '‚àí'}${Math.abs(Number(rounded)).toFixed(digits)}`;
    }

    function formatPoints(val, digits = 1) {
      if (!Number.isFinite(val)) return '‚Äî';
      const rounded = Number(val).toFixed(digits);
      if (Number(rounded) === 0) return '‚âà 0.0 pts';
      return `‚âà ${val > 0 ? '+' : '‚àí'}${Math.abs(Number(rounded)).toFixed(digits)} pts`;
    }

    function describeAdvantage(edge) {
      if (!Number.isFinite(edge)) return { strength: 'nodata', direction: 'nodata', tier: 'NO DATA' };
      if (edge >= 0.06) return { strength: 'strong', direction: 'off', tier: 'STRONG' };
      if (edge >= 0.02) return { strength: 'slight', direction: 'off', tier: 'SLIGHT' };
      if (edge <= -0.06) return { strength: 'strong', direction: 'def', tier: 'STRONG' };
      if (edge <= -0.02) return { strength: 'slight', direction: 'def', tier: 'SLIGHT' };
      return { strength: 'even', direction: 'even', tier: 'EVEN' };
    }

    function formatNumber(val) {
      return Number.isFinite(val) ? val.toFixed(3) : '‚Äî';
    }

    function detailLine(label, value) {
      return `${label}: ${formatNumber(value)}`;
    }

    function toPct(v, scale) {
      if (v === null || v === undefined || v === '') return null;
      const num = Number(v);
      if (!Number.isFinite(num) || !scale || !Number.isFinite(scale.min) || !Number.isFinite(scale.max) || scale.max === scale.min) return null;
      const pct = ((num - scale.min) / (scale.max - scale.min)) * 100;
      return Math.min(100, Math.max(0, pct));
    }

    function buildDumbbell(offVal, oppDefVal, scale, offTeam, defTeam) {
      const missing = [offVal, oppDefVal].some((v) => v === null || v === undefined || v === '');
      const wrap = document.createElement('div');
      wrap.className = 'db-wrap';
      wrap.style.setProperty('--offColor', teamColor(offTeam));
      wrap.style.setProperty('--defColor', teamColor(defTeam));

      const labels = document.createElement('div');
      labels.className = 'db-labels';
      const leftLabel = document.createElement('div');
      leftLabel.className = 'db-label';
      const rightLabel = document.createElement('div');
      rightLabel.className = 'db-label';
      labels.appendChild(leftLabel);
      labels.appendChild(rightLabel);

      const setLabel = (el, text, keyClass) => {
        el.innerHTML = '';
        const key = document.createElement('span');
        key.className = `db-key ${keyClass}`;
        const textNode = document.createElement('span');
        textNode.textContent = text;
        el.appendChild(key);
        el.appendChild(textNode);
      };

      const viz = document.createElement('div');
      viz.className = 'db-viz';
      viz.style.setProperty('--offColor', teamColor(offTeam));
      viz.style.setProperty('--defColor', teamColor(defTeam));

      if (missing) {
        setLabel(leftLabel, `${offTeam} OFF`, 'off');
        setLabel(rightLabel, `${defTeam} DEF`, 'def');
        const placeholder = document.createElement('div');
        placeholder.className = 'db-placeholder';
        placeholder.textContent = 'no EPA';
        viz.appendChild(placeholder);
        wrap.appendChild(labels);
        wrap.appendChild(viz);
        return wrap;
      }

      const off = Number(offVal);
      const def = Number(oppDefVal);
      if (!Number.isFinite(off) || !Number.isFinite(def)) {
        setLabel(leftLabel, `${offTeam} OFF`, 'off');
        setLabel(rightLabel, `${defTeam} DEF`, 'def');
        const placeholder = document.createElement('div');
        placeholder.className = 'db-placeholder';
        placeholder.textContent = 'no EPA';
        viz.appendChild(placeholder);
        wrap.appendChild(labels);
        wrap.appendChild(viz);
        return wrap;
      }

      const inner = document.createElement('div');
      inner.className = 'db-inner';
      viz.appendChild(inner);

      const track = document.createElement('div');
      track.className = 'db-track';
      inner.appendChild(track);

      const zeroPct = toPct(0, scale);
      if (zeroPct !== null && scale && Number.isFinite(scale.min) && Number.isFinite(scale.max) && scale.min <= 0 && scale.max >= 0 && zeroPct >= 0 && zeroPct <= 100) {
        const zero = document.createElement('div');
        zero.className = 'db-zero';
        zero.style.left = `${zeroPct}%`;
        inner.appendChild(zero);
      }

      const offPct = toPct(off, scale);
      const defPct = toPct(def, scale);
      if (offPct === null || defPct === null) {
        setLabel(leftLabel, `${offTeam} OFF`, 'off');
        setLabel(rightLabel, `${defTeam} DEF`, 'def');
        const placeholder = document.createElement('div');
        placeholder.className = 'db-placeholder';
        placeholder.textContent = 'no EPA';
        viz.appendChild(placeholder);
        wrap.appendChild(labels);
        wrap.appendChild(viz);
        return wrap;
      }

      if (offPct <= defPct) {
        setLabel(leftLabel, `${offTeam} OFF`, 'off');
        setLabel(rightLabel, `${defTeam} DEF`, 'def');
      } else {
        setLabel(leftLabel, `${defTeam} DEF`, 'def');
        setLabel(rightLabel, `${offTeam} OFF`, 'off');
      }

      const left = Math.min(offPct, defPct);
      const right = Math.max(offPct, defPct);
      const range = document.createElement('div');
      range.className = 'db-range';
      range.style.left = `${left}%`;
      range.style.width = `${Math.max(2, right - left)}%`;
      inner.appendChild(range);

      const offDot = document.createElement('div');
      offDot.className = 'db-dot off';
      offDot.style.left = `${offPct}%`;
      offDot.title = `${offTeam} Off EPA/play: ${formatNumber(offVal)}`;
      inner.appendChild(offDot);

      const defDot = document.createElement('div');
      defDot.className = 'db-dot def';
      defDot.style.left = `${defPct}%`;
      defDot.title = `${defTeam} Def EPA/play: ${formatNumber(oppDefVal)}`;
      inner.appendChild(defDot);

      wrap.appendChild(labels);
      wrap.appendChild(viz);
      return wrap;
    }

    function computeScaleFromValues(values) {
      if (!Array.isArray(values) || values.length === 0) {
        return { min: -0.15, max: 0.15 };
      }
      const min = Math.min(...values);
      const max = Math.max(...values);
      const span = max - min || 0.05;
      const pad = Math.max(0.01, span * 0.1);
      return { min: min - pad, max: max + pad };
    }

    function computeScaleFromGames(games, ratings, mode, noRatings) {
      const values = [];
      games.forEach((game) => {
        const [teamA, teamB] = game.teams;
        if (!teamA || !teamB) return;

        const pairs = [
          { off: teamA.team, def: teamB.team },
          { off: teamB.team, def: teamA.team },
        ];

        pairs.forEach(({ off, def }) => {
          const offenseEntry = ratings[off] || {};
          const defenseEntry = ratings[def] || {};
          const offEPA = mode === 'sos' ? offenseEntry.adjOffEPA : offenseEntry.offEPA;
          const defEPA = mode === 'sos' ? defenseEntry.adjDefEPA : defenseEntry.defEPA;
          if (!noRatings && Number.isFinite(offEPA)) values.push(offEPA);
          if (!noRatings && Number.isFinite(defEPA)) values.push(defEPA);
        });
      });
      return computeScaleFromValues(values);
    }

    function rankToPercentile(idx, total) {
      if (total <= 1) return 100;
      const pct = (1 - (idx / (total - 1))) * 100;
      return Math.max(1, Math.min(100, Math.round(pct)));
    }

    function buildGameEntries(games, ratings, { noRatings, week, seasonKey }) {
      const lanes = [];
      const lanesByGame = {};
      const gameEntries = [];

      games.forEach((game) => {
        const [teamA, teamB] = game.teams;
        if (!teamA || !teamB) return;

        const offA = mode === 'sos' ? ratings[teamA.team]?.adjOffEPA : ratings[teamA.team]?.offEPA;
        const defA = mode === 'sos' ? ratings[teamA.team]?.adjDefEPA : ratings[teamA.team]?.defEPA;
        const offB = mode === 'sos' ? ratings[teamB.team]?.adjOffEPA : ratings[teamB.team]?.offEPA;
        const defB = mode === 'sos' ? ratings[teamB.team]?.adjDefEPA : ratings[teamB.team]?.defEPA;

        const laneAEdge = !noRatings && Number.isFinite(offA) && Number.isFinite(defB) ? offA - defB : null;
        const laneBEdge = !noRatings && Number.isFinite(offB) && Number.isFinite(defA) ? offB - defA : null;

        const laneA = {
          gameId: game.game_id,
          teamsLabel: `${teamA.team} vs ${teamB.team}`,
          off: teamA.team,
          def: teamB.team,
          offEPA: offA,
          defEPA: defB,
          edge: laneAEdge,
          absEdge: Number.isFinite(laneAEdge) ? Math.abs(laneAEdge) : null,
          desc: describeAdvantage(laneAEdge),
          week,
          seasonKey,
        };

        const laneB = {
          gameId: game.game_id,
          teamsLabel: `${teamA.team} vs ${teamB.team}`,
          off: teamB.team,
          def: teamA.team,
          offEPA: offB,
          defEPA: defA,
          edge: laneBEdge,
          absEdge: Number.isFinite(laneBEdge) ? Math.abs(laneBEdge) : null,
          desc: describeAdvantage(laneBEdge),
          week,
          seasonKey,
        };

        lanes.push(laneA, laneB);
        if (!lanesByGame[game.game_id]) lanesByGame[game.game_id] = [];
        lanesByGame[game.game_id].push(laneA, laneB);

        const hasTotals = Number.isFinite(offA) && Number.isFinite(defA) && Number.isFinite(offB) && Number.isFinite(defB);
        const netA = hasTotals ? (offA + defA) - (offB + defB) : null;

        const winnerTeam = Number.isFinite(netA) ? (netA >= 0 ? teamA.team : teamB.team) : null;
        const netAbs = Number.isFinite(netA) ? Math.abs(netA) : null;
        const netEdge = netAbs;

        const offDriver = winnerTeam
          ? (winnerTeam === teamA.team ? laneAEdge : laneBEdge)
          : null;
        const defDriver = winnerTeam
          ? (winnerTeam === teamA.team ? (Number.isFinite(laneBEdge) ? -laneBEdge : null) : (Number.isFinite(laneAEdge) ? -laneAEdge : null))
          : null;

        gameEntries.push({
          game_id: game.game_id,
          teams: [teamA.team, teamB.team],
          offA,
          defA,
          offB,
          defB,
          laneA,
          laneB,
          netA,
          netEdge,
          netAbs,
          offDriver,
          defDriver,
          winnerTeam,
          totalA: Number.isFinite(offA) && Number.isFinite(defA) ? offA + defA : null,
          totalB: Number.isFinite(offB) && Number.isFinite(defB) ? offB + defB : null,
          week,
          seasonKey,
        });
      });

      return { gameEntries, lanes, lanesByGame };
    }

    function annotateEdgeDistribution(lanes) {
      const valid = lanes.filter((l) => Number.isFinite(l.absEdge));
      const total = valid.length;
      const sorted = valid.slice().sort((a, b) => b.absEdge - a.absEdge);
      sorted.forEach((lane, idx) => {
        lane.rank = idx + 1;
        lane.percentile = rankToPercentile(idx, total);
      });
      return total;
    }

    function annotateGameDistribution(gameEntries) {
      const valid = gameEntries.filter((g) => Number.isFinite(g.netAbs));
      const total = valid.length;
      const sorted = valid.slice().sort((a, b) => b.netAbs - a.netAbs);
      sorted.forEach((game, idx) => {
        game.rank = idx + 1;
        game.percentile = rankToPercentile(idx, total);
      });
      return total;
    }

    function buildEdgeBadge(lane, totalEdges, { showRankMeta = true } = {}) {
      const badge = document.createElement('div');
      badge.className = 'edge-badge';
      const neutralColor = getComputedStyle(document.documentElement).getPropertyValue('--neutral-edge')?.trim() || '#cbd5e1';
      const isNoData = lane.desc.tier === 'NO DATA';
      const advantagedColor = lane.desc.direction === 'off'
        ? teamColor(lane.off)
        : lane.desc.direction === 'def'
          ? teamColor(lane.def)
          : neutralColor;
      badge.style.setProperty('--accent', advantagedColor);
      badge.style.setProperty('--accentText', accentTextColor(advantagedColor));

      const valueEl = document.createElement('div');
      valueEl.className = 'value';
      valueEl.textContent = formatSigned(lane.edge);

      const metaEl = document.createElement('div');
      metaEl.className = 'badge-sub';
      const isEven = lane.desc.direction === 'even';
      const advantagedUnit = lane.desc.direction === 'off'
        ? `${lane.off} Off`
        : lane.desc.direction === 'def'
          ? `${lane.def} Def`
          : 'Even';
      const approxPoints = (!isNoData && !isEven && Number.isFinite(lane.edge))
        ? Math.abs(lane.edge * PLAYS_PER_GAME)
        : null;
      const pointsLabel = Number.isFinite(approxPoints) ? `+${approxPoints.toFixed(1)}` : null;
      const pctText = (!isNoData && lane.percentile != null) ? `P${lane.percentile}` : null;
      const rankText = showRankMeta && (!isNoData && lane.rank && totalEdges) ? `#${lane.rank}/${totalEdges}` : null;
      const primaryLabel = isNoData
        ? 'NO DATA'
        : (isEven ? 'Even' : `${advantagedUnit}${pointsLabel ? ` ${pointsLabel}` : ''}`);
      const metaParts = [primaryLabel];
      if (showRankMeta && pctText) metaParts.push(pctText);
      if (rankText) metaParts.push(rankText);
      metaEl.textContent = metaParts.filter(Boolean).join(' ¬∑ ');

      const tooltipParts = [
        `${lane.off} Off EPA/play: ${formatNumber(lane.offEPA)}`,
        `${lane.def} Def EPA/play: ${formatNumber(lane.defEPA)}`,
        `Edge: ${formatNumber(lane.edge)}`,
        isNoData
          ? 'NO DATA'
          : (lane.desc.tier === 'EVEN' ? 'EVEN' : `${lane.desc.tier} ${lane.desc.direction === 'off' ? 'OFF' : 'DEF'}`),
        pctText,
        rankText,
        (!isNoData && !isEven && pointsLabel) ? formatPoints(approxPoints) : null,
      ].filter(Boolean);
      badge.title = tooltipParts.join(' | ');

      badge.appendChild(valueEl);
      badge.appendChild(metaEl);
      return badge;
    }

    function buildLaneRow(lane, totalEdges, scale, { showGameContext = false, includeDetails = false, showRankMeta = true } = {}) {
      const row = document.createElement('div');
      row.className = 'lane';

      const labelEl = document.createElement('div');
      labelEl.className = 'lane-label';
      const main = document.createElement('div');
      main.innerHTML = `<span style="font-weight:700">${lane.off} OFF</span> vs <span class="sub">${lane.def} DEF</span>`;
      labelEl.appendChild(main);
      if (showGameContext) {
        const sub = document.createElement('div');
        sub.className = 'sub';
        sub.textContent = `${lane.teamsLabel} ¬∑ ${formatWeekLabel(lane.week, lane.seasonKey)}`;
        labelEl.appendChild(sub);
      }
      row.appendChild(labelEl);

      const vizGroup = document.createElement('div');
      vizGroup.className = 'db';
      vizGroup.appendChild(buildDumbbell(lane.offEPA, lane.defEPA, scale, lane.off, lane.def));
      row.appendChild(vizGroup);

      row.appendChild(buildEdgeBadge(lane, totalEdges, { showRankMeta }));

      if (includeDetails) {
        const detail = document.createElement('details');
        detail.className = 'details';
        detail.style.gridColumn = '1 / -1';
        const isNoData = lane.desc.tier === 'NO DATA';
        const tierLabel = isNoData
          ? 'NO DATA'
          : (lane.desc.tier === 'EVEN' ? 'EVEN' : `${lane.desc.tier} ${lane.desc.direction === 'off' ? 'OFF' : 'DEF'}`);
        const pctText = (!isNoData && lane.percentile != null) ? `P${lane.percentile}` : null;
        const rankText = (!isNoData && lane.rank && totalEdges) ? `#${lane.rank}/${totalEdges}` : null;
        const distributionText = [pctText, rankText].filter(Boolean).join(' ¬∑ ');
        detail.innerHTML = `<summary>Details</summary><div>${detailLine('Off EPA/play', lane.offEPA)}<br>${detailLine('Opp Def EPA/play', lane.defEPA)}<br>Edge: ${formatNumber(lane.edge)}<br>${tierLabel}${distributionText ? ` ¬∑ ${distributionText}` : ''}</div>`;
        row.appendChild(detail);
      }

      return row;
    }

    function getOdds(gameId, season, week) {
      const seasonNum = Number(season);
      const normalizedWeek = normalizeWeekValue(week, seasonNum);
      if (!Number.isFinite(seasonNum) || !Number.isFinite(normalizedWeek)) return null;
      const key = `${seasonNum}-${normalizedWeek}-${String(gameId)}`;
      return oddsIndex[key] || null;
    }

    function buildNetBadge(game, gameTotal, { showRankMeta = true, showPercentile = true } = {}) {
      const badge = document.createElement('div');
      badge.className = 'net-badge';
      const accent = game.winnerTeam ? teamColor(game.winnerTeam) : (getComputedStyle(document.documentElement).getPropertyValue('--neutral-edge')?.trim() || '#cbd5e1');
      badge.style.setProperty('--accent', accent);
      badge.style.setProperty('--accentText', accentTextColor(accent));

      const valueEl = document.createElement('div');
      valueEl.className = 'value';
      valueEl.textContent = formatSigned(game.netEdge);
      const pointsEl = document.createElement('div');
      pointsEl.className = 'badge-sub';
      const pctText = showPercentile && Number.isFinite(game.percentile) ? `P${game.percentile}` : null;
      const rankText = showRankMeta && game.rank ? (gameTotal ? `#${game.rank}/${gameTotal}` : `#${game.rank}`) : null;
      const approxPoints = Number.isFinite(game.netEdge) ? formatPoints(epaToPoints(game.netEdge)) : null;
      const metaParts = [approxPoints, pctText, rankText].filter(Boolean);
      pointsEl.textContent = metaParts.join(' ¬∑ ');

      badge.appendChild(valueEl);
      badge.appendChild(pointsEl);
      return badge;
    }

    function buildGameDetails(game, gameTotal) {
      const detail = document.createElement('details');
      detail.className = 'details';
      const summary = document.createElement('summary');
      summary.textContent = 'Details';
      detail.appendChild(summary);

      const body = document.createElement('div');
      const [teamA, teamB] = game.teams;
      const lines = [
        `${teamA}: Off ${formatNumber(game.offA)} ¬∑ Def ${formatNumber(game.defA)} ¬∑ Total ${formatNumber(game.totalA)} (${formatPoints(epaToPoints(game.totalA))})`,
        `${teamB}: Off ${formatNumber(game.offB)} ¬∑ Def ${formatNumber(game.defB)} ¬∑ Total ${formatNumber(game.totalB)} (${formatPoints(epaToPoints(game.totalB))})`,
        `${teamA} OFF vs ${teamB} DEF: ${formatNumber(game.laneA.edge)} (${formatPoints(epaToPoints(game.laneA.edge))})`,
        `${teamB} OFF vs ${teamA} DEF: ${formatNumber(game.laneB.edge)} (${formatPoints(epaToPoints(game.laneB.edge))})`,
        `NET advantage (${game.winnerTeam || '‚Äî'}): ${formatSigned(game.netEdge)} (${formatPoints(epaToPoints(game.netEdge))})`,
        Number.isFinite(game.rank) ? `Rank: #${game.rank}/${gameTotal} ¬∑ P${game.percentile}` : null,
      ].filter(Boolean);
      body.innerHTML = lines.join('<br>');
      detail.appendChild(body);
      return detail;
    }

    function renderGameCards(gameEntries, lanesByGame, edgeCount, { seasonKey, scale, gameTotal }) {
      cardsEl.innerHTML = '';
      cardsEl.classList.toggle('ranked', layoutMode === 'ranked');
      gameEntries.forEach((game) => {
        const [teamA, teamB] = game.teams;
        const card = document.createElement('article');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'card-header';
        const teamsLabel = document.createElement('div');
        teamsLabel.className = 'teams';
        teamsLabel.textContent = `${teamA} vs ${teamB}`;
        const weekLabel = document.createElement('div');
        weekLabel.className = 'week-label';
        weekLabel.textContent = formatWeekLabel(game.week, seasonKey);
        header.appendChild(teamsLabel);
        header.appendChild(weekLabel);
        card.appendChild(header);

        const scoreboard = document.createElement('div');
        scoreboard.className = 'scoreboard';

        const summaryRow = document.createElement('div');
        summaryRow.className = 'game-summary';
        const summaryText = document.createElement('div');
        summaryText.className = 'summary-text';
        const netSummary = game.winnerTeam
          ? `NET: ${game.winnerTeam} ${formatSigned(game.netEdge)} (${formatPoints(epaToPoints(game.netEdge))})`
          : 'NET: ‚Äî';
        summaryText.innerHTML = `<div>${netSummary}</div>`;
        const drivers = document.createElement('div');
        drivers.className = 'drivers';
        drivers.textContent = `Components: OFF ${formatSigned(game.offDriver)} (${formatPoints(epaToPoints(game.offDriver))}) ¬∑ DEF ${formatSigned(game.defDriver)} (${formatPoints(epaToPoints(game.defDriver))})`;
        if (game.winnerTeam) summaryText.appendChild(drivers);
        summaryRow.appendChild(summaryText);
        summaryRow.appendChild(buildNetBadge(game, gameTotal, { showRankMeta: layoutMode === 'ranked', showPercentile: true }));
        scoreboard.appendChild(summaryRow);

        const laneGrid = document.createElement('div');
        laneGrid.className = 'lane-grid';
        (lanesByGame[game.game_id] || []).forEach((lane) => {
          laneGrid.appendChild(buildLaneRow(lane, edgeCount, scale, { includeDetails: false, showRankMeta: layoutMode === 'ranked' }));
        });
        scoreboard.appendChild(laneGrid);

        scoreboard.appendChild(buildGameDetails(game, gameTotal));
        card.appendChild(scoreboard);

        const odds = getOdds(game.game_id, seasonKey, game.week);
        const oddsRow = document.createElement('div');
        oddsRow.className = 'odds';
        const spreadNum = odds?.spread == null ? NaN : Number(odds.spread);
        const spreadValue = odds?.spread_team && Number.isFinite(spreadNum)
          ? `${odds.spread_team} ${spreadNum > 0 ? '+' : ''}${spreadNum}`
          : '‚Äî';
        const totalNum = odds?.total == null ? NaN : Number(odds.total);
        const totalValue = Number.isFinite(totalNum) ? totalNum.toFixed(1) : '‚Äî';

        const oddsPieces = [`Spread: ${spreadValue}`, `O/U: ${totalValue}`];
        const metaParts = [];
        if (odds?.source) metaParts.push(`Lines: ${odds.source}`);
        if (odds?.updated_at) metaParts.push(`updated ${odds.updated_at}`);
        const metaText = metaParts.length ? metaParts.join(' ¬∑ ') : '';
        oddsRow.innerHTML = `<span>${oddsPieces[0]}</span><span>${oddsPieces[1]}</span>${metaText ? `<span class="odds-meta">${metaText}</span>` : ''}`;
        card.appendChild(oddsRow);

        cardsEl.appendChild(card);
      });
    }

    function renderMatchups() {
      hideStatus();
      const infoMessages = [];
      const seasonKey = seasonSelect.value;
      const season = data?.seasons?.[seasonKey];
      if (!season) {
        showStatus('Season data not found.', 'error');
        cardsEl.innerHTML = '';
        return;
      }
      const weeks = getSeasonWeeks(season, seasonKey);
      const week = normalizeWeekValue(weekSelect.value, seasonKey);
      if (!Number.isFinite(week)) {
        cardsEl.innerHTML = '<div class="empty">No games found for this week.</div>';
        return;
      }
      const games = groupGamesForWeek(season, week, seasonKey);
      if (games.length === 0) {
        cardsEl.innerHTML = '<div class="empty">No games found for this week.</div>';
        return;
      }

      const baseRatings = computeTeamAggregates(season, Math.max(1, week), seasonKey);
      const noRatings = Object.keys(baseRatings).length === 0;
      const ratings = mode === 'sos' ? computeSOSAdjustedRatings(season, Math.max(1, week), baseRatings, seasonKey) : baseRatings;
      if (noRatings) {
        infoMessages.push(`No prior games available to compute ratings for ${formatWeekLabel(week, seasonKey)}.`);
      }
      const ratingWeek = Math.max(0, week - 1);
      const weeksLabel = weeks.length ? `${formatWeekLabel(weeks[0], seasonKey)}‚Äì${formatWeekLabel(weeks[weeks.length - 1], seasonKey)}` : 'n/a';
      const ratingWeekText = ratingWeek > 0 ? formatWeekLabel(ratingWeek, seasonKey) : '0 (no prior games)';
      metaEl.textContent = `Weeks: ${weeksLabel}. Ratings through ${ratingWeekText} (${mode === 'sos' ? 'opponent-adjusted' : 'raw'}). Edge: + favors OFF, ‚àí favors DEF.`;

      const scale = computeScaleFromGames(games, ratings, mode, noRatings);
      const { gameEntries, lanes, lanesByGame } = buildGameEntries(games, ratings, { noRatings, week, seasonKey });
      const edgeCount = annotateEdgeDistribution(lanes);
      const gameCount = annotateGameDistribution(gameEntries);

      gamesBtn.classList.toggle('active', layoutMode === 'games');
      rankedBtn.classList.toggle('active', layoutMode === 'ranked');

      const entriesToRender = layoutMode === 'ranked'
        ? gameEntries.slice().sort((a, b) => ((b.netAbs ?? -Infinity) - (a.netAbs ?? -Infinity)))
        : gameEntries;

      renderGameCards(entriesToRender, lanesByGame, edgeCount, { seasonKey, scale, gameTotal: gameCount || gameEntries.length });

      if (oddsPayload && !(oddsPayload.odds || []).some((o) => Number(o.season) === Number(seasonKey) && normalizeWeekValue(o.week, o?.season ?? seasonKey, o?.season_type) === week)) {
        infoMessages.push('Betting lines not available for this week yet.');
      }

      if (infoMessages.length) {
        showStatus(infoMessages.join(' '));
      }

      const fixtureFlag = new URLSearchParams(window.location.search).get('fixture');
      if (fixtureFlag === '1') {
        const dumbbells = cardsEl.querySelectorAll('.db-viz').length;
        console.log('dumbbell count', dumbbells);
      }
    }

    function onSeasonChange() {
      const season = data?.seasons?.[seasonSelect.value];
      if (!season) return;
      const seasonKey = seasonSelect.value;
      const previousWeek = normalizeWeekValue(weekSelect.value, seasonKey);
      const weeks = getSeasonWeeks(season, seasonKey);
      fillSelect(weekSelect, weeks, seasonKey);
      const latestWeek = weeks.length ? weeks[weeks.length - 1] : getCurrentWeek(season, seasonKey);
      const overrideWeek = getWeekOverride(weeks, seasonKey);
      const keepPrevious = userSelectedWeek && Number.isFinite(previousWeek) && weeks.includes(previousWeek);
      const defaultWeek = overrideWeek ?? (keepPrevious ? previousWeek : latestWeek);
      weekSelect.value = defaultWeek;
      renderMatchups();
    }

    async function fetchOdds() {
      try {
        const oddsUrl = new URL(ODDS_URL);
        oddsUrl.searchParams.set('v', String(Date.now()));
        const res = await fetch(oddsUrl, { cache: 'no-store' });
        if (!res.ok) throw new Error('Failed to load odds');
        oddsPayload = normalizeOdds(await res.json());
        oddsIndex = {};
        (oddsPayload.odds || []).forEach((o) => {
          const seasonNum = Number(o.season);
          const weekNum = normalizeWeekValue(o.week, seasonNum, o?.season_type);
          if (!Number.isFinite(seasonNum) || !Number.isFinite(weekNum)) return;
          const key = `${seasonNum}-${weekNum}-${String(o.game_id)}`;
          oddsIndex[key] = o;
        });
      } catch (err) {
        oddsPayload = { odds: [] };
        oddsIndex = {};
        console.warn('Odds not available', err);
      }
    }

    async function init() {
      showStatus('Loading data...');
      try {
        const dataUrl = new URL(DATA_URL);
        dataUrl.searchParams.set('v', String(Date.now()));
        const res = await fetch(dataUrl, { cache: 'no-store' });
        if (!res.ok) throw new Error('Failed to load data file');
        data = await res.json();
      } catch (err) {
        console.error(err);
        showStatus('Could not load data/epa.json. Please refresh or try again later.', 'error');
        return;
      }
      await fetchSchedule();
      computeRegMaxBySeasonFromSchedule();
      mergeScheduleIntoData();
      hideStatus();
      await fetchOdds();
      mergeOddsScheduleIntoData();
      repairGamesFromScheduleAndOdds();

      const seasons = Object.keys(data.seasons || {}).sort((a, b) => Number(b) - Number(a));
      seasons.forEach((season) => {
        const option = document.createElement('option');
        option.value = season;
        option.textContent = season;
        seasonSelect.appendChild(option);
      });
      const defaultSeason = seasons[0];
      seasonSelect.value = defaultSeason;
      onSeasonChange();
    }

    seasonSelect.addEventListener('change', () => {
      userSelectedWeek = false;
      onSeasonChange();
    });
    weekSelect.addEventListener('change', () => {
      userSelectedWeek = true;
      renderMatchups();
    });
    rawBtn.addEventListener('click', () => {
      mode = 'raw';
      rawBtn.classList.add('active');
      sosBtn.classList.remove('active');
      renderMatchups();
    });
    sosBtn.addEventListener('click', () => {
      mode = 'sos';
      sosBtn.classList.add('active');
      rawBtn.classList.remove('active');
      renderMatchups();
    });

    gamesBtn.addEventListener('click', () => {
      layoutMode = 'games';
      localStorage.setItem('layoutMode', layoutMode);
      renderMatchups();
    });

    rankedBtn.addEventListener('click', () => {
      layoutMode = 'ranked';
      localStorage.setItem('layoutMode', layoutMode);
      renderMatchups();
    });

    init();
  </script>
</body>
</html>
