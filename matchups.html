<!-- PATCH: fix defense sign convention (def_epa_pp is DEFENSE STRENGTH, higher=better) -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NFL Weekly Matchups</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: light;
      --border: #e2e8f0;
      --text: #0f172a;
      --muted: #475569;
      --panel: #f8fafc;
      --pill-strong: #2563eb;
      --pill-slight: #0ea5e9;
      --pill-neutral: #94a3b8;
      --pill-def: #f97316;
    }

    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      color: var(--text);
      margin: 0;
      padding: 2rem 1.5rem 3rem;
      background: #ffffff;
    }

    main { max-width: 1100px; margin: 0 auto; }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    h1 { margin: 0 0 0.35rem; font-size: 1.9rem; }
    p.lead { margin: 0 0 0.65rem; color: var(--muted); }
    .meta { color: var(--muted); margin: 0 0 0.5rem; }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem 1rem;
      align-items: center;
      margin: 0.2rem 0 0.8rem;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .legend strong { color: var(--text); }

    .nav-actions {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: flex-end;
    }

    .hof-link {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.5rem 0.9rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: white;
      font-weight: 700;
      color: #0f172a;
      text-decoration: none;
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.08);
      transition: transform 120ms ease, box-shadow 120ms ease;
      white-space: nowrap;
    }

    .hof-link:hover { transform: translateY(-1px); box-shadow: 0 10px 18px rgba(15, 23, 42, 0.12); }

    .controls {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      margin: 1rem 0 1.5rem;
    }

    label { font-weight: 600; display: block; margin-bottom: 0.25rem; }

    select, button {
      width: 100%;
      padding: 0.6rem 0.7rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
      background: white;
    }

    .toggle {
      display: inline-flex;
      gap: 0.5rem;
      align-items: center;
    }

    .toggle button {
      flex: 1;
      cursor: pointer;
      font-weight: 700;
      color: #0f172a;
      background: white;
      box-shadow: none;
      border: 1px solid var(--border);
    }

    .toggle button.active {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: white;
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.2);
      border: none;
    }

    .notice {
      background: #fff7ed;
      border: 1px solid #fed7aa;
      border-radius: 10px;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
      color: #9a3412;
    }

    .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1rem; }

    .card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      container-type: inline-size;
    }

    .card-header { display: flex; justify-content: space-between; gap: 0.5rem; align-items: center; }
    .teams { font-weight: 700; font-size: 1.05rem; }
    .week-label { color: var(--muted); font-size: 0.95rem; }

    .matchup-row {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 2.2fr) auto;
      gap: 1rem;
      align-items: center;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.85rem 1rem;
      background: var(--panel);
    }

    .matchup-row .label { font-weight: 700; }
    .metrics { text-align: right; color: var(--muted); font-variant-numeric: tabular-nums; display: flex; flex-direction: column; gap: 0.3rem; align-items: flex-end; }

    .edge-badge {
      display: inline-flex;
      align-items: flex-end;
      justify-content: center;
      gap: 0.05rem;
      padding: 0.6rem 0.9rem;
      border-radius: 10px;
      color: white;
      font-weight: 800;
      font-size: 1.24rem;
      line-height: 1.05;
      min-width: 110px;
      text-align: right;
      white-space: nowrap;
    }

    .edge-badge .edge-value { font-size: 1.24rem; letter-spacing: 0.02em; }

    .edge-badge.strong { background: var(--pill-strong); }
    .edge-badge.slight { background: var(--pill-slight); }
    .edge-badge.neutral { background: var(--pill-neutral); color: var(--text); }
    .edge-badge.defense { background: var(--pill-def); }

    .odds { color: var(--muted); font-size: 0.95rem; display: flex; justify-content: space-between; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    .odds .odds-meta { flex-basis: 100%; font-size: 0.9rem; color: var(--muted); }

    .empty { text-align: center; color: var(--muted); border: 1px dashed var(--border); border-radius: 12px; padding: 1rem; }

    /* Dumbbell */
    .db { display: flex; flex-direction: column; gap: 0.35rem; flex: 1; min-width: 220px; }
    /* NOTE: db-viz must NOT be flex:1 (flex-basis:0). Its children are absolutely positioned,
       so flex:1 can collapse it to 0px tall and the dumbbell becomes invisible. */
    .db-viz { position: relative; flex: 0 0 auto; min-width: 220px; height: 26px; background: white; border: 1px solid var(--border); border-radius: 999px; }
    /* Inner frame creates real horizontal padding for %-positioned dots/range */
    .db-inner { position: absolute; inset: 0 14px; }

    .db-track { position: absolute; inset: 7px 0; background: var(--panel); border-radius: 999px; }
    .db-zero { position: absolute; top: 5px; width: 2px; height: 16px; background: var(--border); transform: translateX(-50%); }
    .db-range { position: absolute; top: 9px; height: 8px; background: linear-gradient(90deg, #2563eb, #f97316); border-radius: 999px; opacity: 0.85; }
    .db-dot { position: absolute; top: 50%; width: 18px; height: 18px; border-radius: 50%; border: 2px solid white; box-shadow: 0 3px 8px rgba(15, 23, 42, 0.16); transform: translate(-50%, -50%); }
    .db-dot.off { background: #2563eb; }
    .db-dot.def { background: #f97316; }
    .db-placeholder { position: absolute; inset: 0; display: grid; place-items: center; font-size: 0.85rem; color: var(--muted); background: rgba(226, 232, 240, 0.4); border-radius: 999px; }

    details.matchup-details { color: var(--muted); font-size: 0.95rem; }
    details.matchup-details summary { cursor: pointer; font-weight: 600; color: var(--text); list-style: none; }
    details.matchup-details summary::-webkit-details-marker { display: none; }
    details.matchup-details summary::marker { content: ""; }
    details.matchup-details summary::after { content: '‚ñ∏'; margin-left: 0.35rem; font-size: 0.8rem; }
    details.matchup-details[open] summary::after { content: '‚ñæ'; }
    details.matchup-details .detail-lines { margin-top: 0.4rem; line-height: 1.3; }

    @media (max-width: 640px) {
      body { padding: 1.5rem 1rem 2.5rem; }
      .matchup-row { grid-template-columns: 1fr; align-items: flex-start; }
      .edge-badge { align-self: flex-start; }
      .metrics { text-align: left; align-items: flex-start; }
    }

    @media (max-width: 800px) {
      .db { min-width: 0; }
      .db-viz { width: 100%; min-width: 0; }
    }

    /* Card-width responsiveness (cards can be narrow even on wide viewports) */
    @container (max-width: 520px) {
      .matchup-row { grid-template-columns: 1fr; align-items: flex-start; }
      .edge-badge { align-self: flex-start; }
      .metrics { text-align: left; align-items: flex-start; }
      .db { min-width: 0; }
      .db-viz { width: 100%; min-width: 0; }
    }
  </style>
</head>
<body>
  <main>
    <div class="top-bar">
      <div>
        <h1>Weekly Matchups</h1>
        <p class="lead">Offense vs defense EPA/play edges for every game. Toggle raw vs opponent-adjusted views and pick any week.</p>
        <p id="meta" class="meta"></p>
        <div class="legend" aria-label="Dumbbell legend">
          <span><strong>Blue dot</strong> = Off EPA/play</span>
          <span><strong>Orange dot</strong> = Opponent Def EPA/play (higher = better)</span>
          <span><strong>Center tick</strong> shows 0 only when the scale includes it</span>
          <span><strong>Edge</strong> = Off ‚àí OppDef (positive favors offense)</span>
        </div>
      </div>
      <div class="nav-actions">
        <a class="hof-link" href="index.html" aria-label="Back to EPA chart">‚¨ÖÔ∏è Back</a>
        <a class="hof-link" href="hof.html" aria-label="View EPA Hall of Fame">üèÜ HOF</a>
      </div>
    </div>

    <div id="status" class="notice" hidden></div>

    <section class="controls">
      <div>
        <label for="season-select">Season</label>
        <select id="season-select"></select>
      </div>
      <div>
        <label for="week-select">Week</label>
        <select id="week-select"></select>
      </div>
      <fieldset style="border: none; padding: 0; margin: 0;">
        <legend style="font-weight: 600; margin-bottom: 0.25rem; padding: 0;">View</legend>
        <div class="toggle" role="group" aria-label="Raw vs opponent-adjusted">
          <button id="raw-btn" class="active" type="button">Raw</button>
          <button id="sos-btn" type="button">Opponent-adjusted</button>
        </div>
      </fieldset>
    </section>

    <div id="cards" class="cards" aria-live="polite"></div>
  </main>

  <script>
    const statusEl = document.getElementById('status');
    const metaEl = document.getElementById('meta');
    const seasonSelect = document.getElementById('season-select');
    const weekSelect = document.getElementById('week-select');
    const cardsEl = document.getElementById('cards');
    const rawBtn = document.getElementById('raw-btn');
    const sosBtn = document.getElementById('sos-btn');

    const DATA_URL = new URL('data/epa.json', document.baseURI);
    const ODDS_URL = new URL('data/odds.json', document.baseURI);

    let data;
    let oddsPayload = null;
    let oddsIndex = {};
    let mode = 'raw';

    function showStatus(message, variant = 'info') {
      statusEl.textContent = message;
      statusEl.hidden = false;
      statusEl.style.display = 'block';
      statusEl.style.borderColor = variant === 'error' ? '#f97316' : '#fed7aa';
      statusEl.style.background = variant === 'error' ? '#fff1f2' : '#fff7ed';
      statusEl.style.color = variant === 'error' ? '#9f1239' : '#9a3412';
    }

    function hideStatus() {
      statusEl.hidden = true;
      statusEl.textContent = '';
    }

    function getCurrentWeek(season) {
      if (Array.isArray(season?.weeks) && season.weeks.length > 0) {
        return Math.max(...season.weeks);
      }
      const maxWeek = season?.games?.reduce((max, g) => Math.max(max, g.week || 0), 0) || 1;
      return maxWeek;
    }

    function fillSelect(selectEl, values) {
      selectEl.innerHTML = '';
      values.forEach((val) => {
        const option = document.createElement('option');
        option.value = val;
        option.textContent = `Week ${val}`;
        selectEl.appendChild(option);
      });
    }

    function groupGamesForWeek(season, week) {
      const byId = {};
      (season.games || []).forEach((g) => {
        if (Number(g.week) !== Number(week)) return;
        if (!byId[g.game_id]) {
          byId[g.game_id] = { game_id: g.game_id, teams: [] };
        }
        byId[g.game_id].teams.push(g);
      });
      return Object.values(byId);
    }

    function computeTeamAggregates(season, week) {
      const aggregates = {};
      const includeGame = (g, limit) => Number(g.week) < Number(limit);

      const addGame = (g) => {
        if (!aggregates[g.team]) {
          aggregates[g.team] = { offSum: 0, offPlays: 0, defSum: 0, defPlays: 0 };
        }
        const entry = aggregates[g.team];
        if (Number.isFinite(g.off_epa_pp) && Number.isFinite(g.off_plays)) {
          entry.offSum += g.off_epa_pp * g.off_plays;
          entry.offPlays += g.off_plays;
        }
        if (Number.isFinite(g.def_epa_pp) && Number.isFinite(g.def_plays)) {
          entry.defSum += g.def_epa_pp * g.def_plays;
          entry.defPlays += g.def_plays;
        }
      };

      (season.games || []).forEach((g) => {
        if (includeGame(g, week)) addGame(g);
      });

      const ratings = {};
      Object.entries(aggregates).forEach(([team, entry]) => {
        const offEPA = entry.offPlays > 0 ? entry.offSum / entry.offPlays : null;
        const defEPA = entry.defPlays > 0 ? entry.defSum / entry.defPlays : null;
        ratings[team] = {
          offEPA,
          defEPA,
          offPlays: entry.offPlays,
          defPlays: entry.defPlays,
        };
      });
      return ratings;
    }

    function computeSOSAdjustedRatings(season, week, baseRatings) {
      const totals = { offEpaSum: 0, offPlays: 0, defEpaSum: 0, defPlays: 0 };
      Object.values(baseRatings).forEach((entry) => {
        if (Number.isFinite(entry.offEPA)) {
          totals.offEpaSum += entry.offEPA * entry.offPlays;
          totals.offPlays += entry.offPlays;
        }
        if (Number.isFinite(entry.defEPA)) {
          totals.defEpaSum += entry.defEPA * entry.defPlays;
          totals.defPlays += entry.defPlays;
        }
      });

      const leagueAvgOffEPA = totals.offPlays ? totals.offEpaSum / totals.offPlays : 0;
      const leagueAvgDefEPA = totals.defPlays ? totals.defEpaSum / totals.defPlays : 0;

      const opponentFacings = {};
      (season.games || []).forEach((g) => {
        if (g.week >= week) return;
        if (!opponentFacings[g.team]) {
          opponentFacings[g.team] = { oppOffEpa: 0, oppDefEpa: 0, offPlays: 0, defPlays: 0 };
        }
        const oppRatings = baseRatings[g.opp];
        if (!oppRatings) return;
        const facing = opponentFacings[g.team];
        if (Number.isFinite(g.off_plays) && Number.isFinite(oppRatings.defEPA)) {
          facing.offPlays += g.off_plays;
          facing.oppDefEpa += g.off_plays * oppRatings.defEPA;
        }
        if (Number.isFinite(g.def_plays) && Number.isFinite(oppRatings.offEPA)) {
          facing.defPlays += g.def_plays;
          facing.oppOffEpa += g.def_plays * oppRatings.offEPA;
        }
      });

      const adjusted = {};
      // NOTE: def_epa_pp in this repo is DEFENSE STRENGTH (sign-flipped in the pipeline so higher = better defense).
      // Opponent-adjusted (one-pass) EPA:
      //   OffEPA_adj = OffEPA + avgOppDefEPA - leagueAvgDefEPA
      //   DefEPA_adj = DefEPA + avgOppOffEPA - leagueAvgOffEPA
      Object.entries(baseRatings).forEach(([team, entry]) => {
        const facing = opponentFacings[team] || {};
        const avgOppDefEPA = facing.offPlays ? facing.oppDefEpa / facing.offPlays : leagueAvgDefEPA;
        const avgOppOffEPA = facing.defPlays ? facing.oppOffEpa / facing.defPlays : leagueAvgOffEPA;

        const adjOffEPA = Number.isFinite(entry.offEPA)
          ? entry.offEPA + avgOppDefEPA - leagueAvgDefEPA
          : null;
        const adjDefEPA = Number.isFinite(entry.defEPA)
          ? entry.defEPA + avgOppOffEPA - leagueAvgOffEPA
          : null;

        adjusted[team] = {
          ...entry,
          adjOffEPA,
          adjDefEPA,
        };
      });

      return adjusted;
    }

    function labelForAdvantage(edge) {
      if (!Number.isFinite(edge)) return { label: 'Insufficient data', tone: 'neutral' };
      if (edge >= 0.06) return { label: 'Strong edge (offense)', tone: 'strong' };
      if (edge >= 0.02) return { label: 'Slight edge (offense)', tone: 'slight' };
      if (edge > -0.02) return { label: 'Neutral', tone: 'neutral' };
      if (edge > -0.06) return { label: 'Slight edge (defense)', tone: 'defense' };
      return { label: 'Strong edge (defense)', tone: 'defense' };
    }

    function formatNumber(val) {
      return Number.isFinite(val) ? val.toFixed(3) : '‚Äî';
    }

    function formatBadgeNumber(val) {
      if (!Number.isFinite(val)) return '‚Äî';
      const fixed = Math.abs(val).toFixed(2);
      if (val > 0) return `+${fixed}`;
      if (val < 0) return `‚àí${fixed}`;
      return '0.00';
    }

    function detailLine(label, value, plays) {
      const playsLabel = Number.isFinite(plays) ? ` (${plays} plays)` : '';
      return `${label}: ${formatNumber(value)}${playsLabel}`;
    }

    function toPct(v, scale) {
      if (v === null || v === undefined || v === '') return null;
      const num = Number(v);
      if (!Number.isFinite(num) || !scale || !Number.isFinite(scale.min) || !Number.isFinite(scale.max) || scale.max === scale.min) return null;
      const pct = ((num - scale.min) / (scale.max - scale.min)) * 100;
      return Math.min(100, Math.max(0, pct));
    }

    function buildDumbbell(offVal, oppDefVal, scale, { offPlays, defPlays, offLabel = 'Offense', defLabel = 'Defense' } = {}) {
      const missing = [offVal, oppDefVal].some((v) => v === null || v === undefined || v === '');
      const viz = document.createElement('div');
      viz.className = 'db-viz';

      if (missing) {
        const placeholder = document.createElement('div');
        placeholder.className = 'db-placeholder';
        placeholder.textContent = 'no EPA';
        viz.appendChild(placeholder);
        return viz;
      }

      const off = Number(offVal);
      const def = Number(oppDefVal);
      if (!Number.isFinite(off) || !Number.isFinite(def)) {
        const placeholder = document.createElement('div');
        placeholder.className = 'db-placeholder';
        placeholder.textContent = 'no EPA';
        viz.appendChild(placeholder);
        return viz;
      }

      const inner = document.createElement('div');
      inner.className = 'db-inner';
      viz.appendChild(inner);

      const track = document.createElement('div');
      track.className = 'db-track';
      inner.appendChild(track);

      const zeroPct = toPct(0, scale);
      if (zeroPct !== null && scale && Number.isFinite(scale.min) && Number.isFinite(scale.max) && scale.min <= 0 && scale.max >= 0 && zeroPct >= 0 && zeroPct <= 100) {
        const zero = document.createElement('div');
        zero.className = 'db-zero';
        zero.style.left = `${zeroPct}%`;
        inner.appendChild(zero);
      }

      const offPct = toPct(off, scale);
      const defPct = toPct(def, scale);
      if (offPct === null || defPct === null) {
        const placeholder = document.createElement('div');
        placeholder.className = 'db-placeholder';
        placeholder.textContent = 'no EPA';
        viz.appendChild(placeholder);
        return viz;
      }

      const left = Math.min(offPct, defPct);
      const right = Math.max(offPct, defPct);
      const range = document.createElement('div');
      range.className = 'db-range';
      range.style.left = `${left}%`;
      range.style.width = `${Math.max(2, right - left)}%`;
      inner.appendChild(range);

      const offDot = document.createElement('div');
      offDot.className = 'db-dot off';
      offDot.style.left = `${offPct}%`;
      offDot.title = `${offLabel}: ${formatNumber(off)}${Number.isFinite(offPlays) ? ` (${offPlays} plays)` : ''}`;
      inner.appendChild(offDot);

      const defDot = document.createElement('div');
      defDot.className = 'db-dot def';
      defDot.style.left = `${defPct}%`;
      defDot.title = `${defLabel}: ${formatNumber(def)}${Number.isFinite(defPlays) ? ` (${defPlays} plays)` : ''}`;
      inner.appendChild(defDot);

      return viz;
    }

    function computeScaleFromValues(values) {
      if (!Array.isArray(values) || values.length === 0) {
        return { min: -0.15, max: 0.15 };
      }
      const min = Math.min(...values);
      const max = Math.max(...values);
      const span = max - min || 0.05;
      const pad = Math.max(0.01, span * 0.1);
      return { min: min - pad, max: max + pad };
    }

    function computeScaleFromGames(games, ratings, mode, noRatings) {
      const values = [];
      games.forEach((game) => {
        const [teamA, teamB] = game.teams;
        if (!teamA || !teamB) return;

        const pairs = [
          { off: teamA.team, def: teamB.team },
          { off: teamB.team, def: teamA.team },
        ];

        pairs.forEach(({ off, def }) => {
          const offenseEntry = ratings[off] || {};
          const defenseEntry = ratings[def] || {};
          const offEPA = mode === 'sos' ? offenseEntry.adjOffEPA : offenseEntry.offEPA;
          const defEPA = mode === 'sos' ? defenseEntry.adjDefEPA : defenseEntry.defEPA;
          if (!noRatings && Number.isFinite(offEPA)) values.push(offEPA);
          if (!noRatings && Number.isFinite(defEPA)) values.push(defEPA);
        });
      });
      return computeScaleFromValues(values);
    }

    function getOdds(gameId, season, week) {
      const key = `${Number(season)}-${Number(week)}-${String(gameId)}`;
      return oddsIndex[key] || null;
    }

    function renderGames(games, ratings, { noRatings, week, seasonKey, scale }) {
      cardsEl.innerHTML = '';
      games.forEach((game) => {
        const [teamA, teamB] = game.teams;
        if (!teamA || !teamB) return;
        const offA = teamA.team;
        const offB = teamB.team;

        const matchups = [
          { off: offA, def: offB, label: `${offA} offense vs ${offB} defense` },
          { off: offB, def: offA, label: `${offB} offense vs ${offA} defense` },
        ];

        const card = document.createElement('article');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'card-header';
        const teamsLabel = document.createElement('div');
        teamsLabel.className = 'teams';
        teamsLabel.textContent = `${offA} vs ${offB}`;
        const weekLabel = document.createElement('div');
        weekLabel.className = 'week-label';
        weekLabel.textContent = `Week ${week}`;
        header.appendChild(teamsLabel);
        header.appendChild(weekLabel);
        card.appendChild(header);

        matchups.forEach((m) => {
          const offenseEntry = ratings[m.off] || {};
          const defenseEntry = ratings[m.def] || {};
          const offEPA = mode === 'sos' ? offenseEntry.adjOffEPA : offenseEntry.offEPA;
          const defEPA = mode === 'sos' ? defenseEntry.adjDefEPA : defenseEntry.defEPA;
          const offPlays = offenseEntry.offPlays;
          const defPlays = defenseEntry.defPlays;

          // def_epa_pp is defense strength (higher = better). Matchup edge = OffEPA - OppDefEPA.
          const hasRowData = !noRatings && Number.isFinite(offEPA) && Number.isFinite(defEPA);
          const edge = hasRowData ? offEPA - defEPA : null;
          const { tone } = labelForAdvantage(edge);

          const row = document.createElement('div');
          row.className = 'matchup-row';

          const labelEl = document.createElement('div');
          labelEl.className = 'label';
          labelEl.textContent = m.label;

          const vizGroup = document.createElement('div');
          vizGroup.className = 'db';
          vizGroup.appendChild(buildDumbbell(offEPA, defEPA, scale, {
            offPlays,
            defPlays,
            offLabel: `${m.off} offense`,
            defLabel: `${m.def} defense`,
          }));

          const metricsEl = document.createElement('div');
          metricsEl.className = 'metrics';

          const badge = document.createElement('div');
          badge.className = `edge-badge ${tone}`;
          const playsTooltip = [
            detailLine('Off EPA/play', offEPA, offPlays),
            detailLine('Opp Def EPA/play (higher = better defense)', defEPA, defPlays),
            `Edge: ${formatNumber(edge)} (Off plays: ${Number.isFinite(offPlays) ? offPlays : '‚Äî'}, OppDef plays: ${Number.isFinite(defPlays) ? defPlays : '‚Äî'})`,
          ];
          badge.title = playsTooltip.join('\n');
          const badgeValue = document.createElement('div');
          badgeValue.className = 'edge-value';
          const badgeDirection = tone === 'defense' ? 'DEF' : tone === 'neutral' ? 'EVEN' : 'OFF';
          badgeValue.textContent = `${formatBadgeNumber(edge)} ${badgeDirection}`;
          badge.appendChild(badgeValue);

          const detail = document.createElement('details');
          detail.className = 'matchup-details';
          const summary = document.createElement('summary');
          summary.textContent = 'Details';
          const detailLines = document.createElement('div');
          detailLines.className = 'detail-lines';
          detailLines.innerHTML = [
            detailLine('Off EPA/play', offEPA, offPlays),
            detailLine('Opp Def EPA/play (higher = better defense)', defEPA, defPlays),
            `Edge: ${formatNumber(edge)}`,
          ].join('<br>');
          detail.appendChild(summary);
          detail.appendChild(detailLines);

          metricsEl.appendChild(badge);
          metricsEl.appendChild(detail);

          row.appendChild(labelEl);
          row.appendChild(vizGroup);
          row.appendChild(metricsEl);
          card.appendChild(row);
        });

        const odds = getOdds(game.game_id, seasonKey, week);
        const oddsRow = document.createElement('div');
        oddsRow.className = 'odds';
        const spreadNum = Number(odds?.spread);
        const spreadValue = odds?.spread_team && Number.isFinite(spreadNum)
          ? `${odds.spread_team} ${spreadNum > 0 ? '+' : ''}${spreadNum}`
          : '‚Äî';
        const totalNum = Number(odds?.total);
        const totalValue = Number.isFinite(totalNum) ? totalNum.toFixed(1) : '‚Äî';

        const oddsPieces = [`Spread: ${spreadValue}`, `O/U: ${totalValue}`];
        const metaParts = [];
        if (odds?.source) metaParts.push(`Lines: ${odds.source}`);
        if (odds?.updated_at) metaParts.push(`updated ${odds.updated_at}`);
        const metaText = metaParts.length ? metaParts.join(' ¬∑ ') : '';
        oddsRow.innerHTML = `<span>${oddsPieces[0]}</span><span>${oddsPieces[1]}</span>${metaText ? `<span class="odds-meta">${metaText}</span>` : ''}`;
        card.appendChild(oddsRow);

        cardsEl.appendChild(card);
      });
    }

    function renderMatchups() {
      hideStatus();
      const infoMessages = [];
      const seasonKey = seasonSelect.value;
      const season = data?.seasons?.[seasonKey];
      if (!season) {
        showStatus('Season data not found.', 'error');
        cardsEl.innerHTML = '';
        return;
      }
      const week = Number(weekSelect.value);
      const games = groupGamesForWeek(season, week);
      if (games.length === 0) {
        cardsEl.innerHTML = '<div class="empty">No games found for this week.</div>';
        return;
      }

      const baseRatings = computeTeamAggregates(season, Math.max(1, week));
      const noRatings = Object.keys(baseRatings).length === 0;
      const ratings = mode === 'sos' ? computeSOSAdjustedRatings(season, Math.max(1, week), baseRatings) : baseRatings;
      if (noRatings) {
        infoMessages.push(`No prior games available to compute ratings for Week ${week}. Select Week 2+.`);
      }
      const ratingWeek = Math.max(0, week - 1);
      const sortedWeeks = (season.weeks || []).slice().sort((a, b) => Number(a) - Number(b));
      const weeksLabel = sortedWeeks.length ? `${sortedWeeks[0]}-${sortedWeeks[sortedWeeks.length - 1]}` : 'n/a';
      const ratingWeekText = ratingWeek > 0 ? ratingWeek : '0 (no prior games)';
      metaEl.textContent = `Weeks available: ${weeksLabel}. Ratings use games through Week ${ratingWeekText} (${mode === 'sos' ? 'opponent-adjusted' : 'raw'} EPA/play). Edge = OffEPA - OppDefEPA (defense higher=better).`;

      const scale = computeScaleFromGames(games, ratings, mode, noRatings);
      renderGames(games, ratings, { noRatings, week, seasonKey, scale });

      if (oddsPayload && !(oddsPayload.odds || []).some((o) => Number(o.season) === Number(seasonKey) && Number(o.week) === Number(week))) {
        infoMessages.push('Betting lines not available for this week yet.');
      }

      if (infoMessages.length) {
        showStatus(infoMessages.join(' '));
      }

      const fixtureFlag = new URLSearchParams(window.location.search).get('fixture');
      if (fixtureFlag === '1') {
        const dumbbells = cardsEl.querySelectorAll('.db-viz').length;
        console.log('dumbbell count', dumbbells);
      }
    }

    function onSeasonChange() {
      const season = data?.seasons?.[seasonSelect.value];
      if (!season) return;
      const weeks = (season.weeks || []).slice().sort((a, b) => Number(a) - Number(b));
      fillSelect(weekSelect, weeks);
      const defaultWeek = weeks.length ? Math.max(...weeks.map((w) => Number(w))) : getCurrentWeek(season);
      weekSelect.value = defaultWeek;
      renderMatchups();
    }

    async function fetchOdds() {
      try {
        const res = await fetch(ODDS_URL);
        if (!res.ok) throw new Error('Failed to load odds');
        oddsPayload = await res.json();
        oddsIndex = {};
        (oddsPayload.odds || []).forEach((o) => {
          const key = `${Number(o.season)}-${Number(o.week)}-${String(o.game_id)}`;
          oddsIndex[key] = o;
        });
      } catch (err) {
        oddsPayload = null;
        oddsIndex = {};
        console.warn('Odds not available', err);
      }
    }

    async function init() {
      showStatus('Loading data...');
      try {
        const res = await fetch(DATA_URL);
        if (!res.ok) throw new Error('Failed to load data file');
        data = await res.json();
      } catch (err) {
        console.error(err);
        showStatus('Could not load data/epa.json. Please refresh or try again later.', 'error');
        return;
      }
      hideStatus();
      await fetchOdds();

      const seasons = Object.keys(data.seasons || {}).sort((a, b) => Number(b) - Number(a));
      seasons.forEach((season) => {
        const option = document.createElement('option');
        option.value = season;
        option.textContent = season;
        seasonSelect.appendChild(option);
      });
      const defaultSeason = seasons[0];
      seasonSelect.value = defaultSeason;
      onSeasonChange();
    }

    seasonSelect.addEventListener('change', onSeasonChange);
    weekSelect.addEventListener('change', renderMatchups);
    rawBtn.addEventListener('click', () => {
      mode = 'raw';
      rawBtn.classList.add('active');
      sosBtn.classList.remove('active');
      renderMatchups();
    });
    sosBtn.addEventListener('click', () => {
      mode = 'sos';
      sosBtn.classList.add('active');
      rawBtn.classList.remove('active');
      renderMatchups();
    });

    init();
  </script>
</body>
</html>
